{"modules":{"0.349185945662254":{"definition":"//\n// read stl\n//\n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2018\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'read STL'\n    //\n    // initialization\n    //\n    var init = function() {}\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {\n        mesh: {\n            type: 'STL',\n            event: function(buffer) {\n                mods.output(mod, 'mesh', buffer)\n            }\n        }\n    }\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //\n        // file input control\n        //\n        var file = document.createElement('input')\n        file.setAttribute('type', 'file')\n        file.setAttribute('id', div.id + 'file_input')\n        file.style.position = 'absolute'\n        file.style.left = 0\n        file.style.top = 0\n        file.style.width = 0\n        file.style.height = 0\n        file.style.opacity = 0\n        file.addEventListener('change', function() {\n            stl_read_handler()\n        })\n        div.appendChild(file)\n        mod.file = file\n        //\n        // canvas\n        //\n        var canvas = document.createElement('canvas')\n        canvas.width = mods.ui.canvas\n        canvas.height = mods.ui.canvas\n        canvas.style.backgroundColor = 'rgb(255,255,255)'\n        div.appendChild(canvas)\n        mod.canvas = canvas\n        div.appendChild(document.createElement('br'))\n        //\n        // file select button\n        //\n        var btn = document.createElement('button')\n        btn.style.padding = mods.ui.padding\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('select stl file'))\n        btn.addEventListener('click', function() {\n            var file = document.getElementById(div.id + 'file_input')\n            file.value = null\n            file.click()\n        })\n        div.appendChild(btn)\n        div.appendChild(document.createElement('br'))\n        //\n        // info\n        //\n        var info = document.createElement('div')\n        info.setAttribute('id', div.id + 'info')\n        var text = document.createTextNode('name: ')\n        info.appendChild(text)\n        mod.namen = text\n        info.appendChild(document.createElement('br'))\n        var text = document.createTextNode('size: ')\n        info.appendChild(text)\n        mod.sizen = text\n        info.appendChild(document.createElement('br'))\n        var text = document.createTextNode('triangles: ')\n        info.appendChild(text)\n        mod.trianglesn = text\n        info.appendChild(document.createElement('br'))\n        var text = document.createTextNode('dx: ')\n        info.appendChild(text)\n        mod.dxn = text\n        info.appendChild(document.createElement('br'))\n        var text = document.createTextNode('dy: ')\n        info.appendChild(text)\n        mod.dyn = text\n        info.appendChild(document.createElement('br'))\n        var text = document.createTextNode('dz: ')\n        info.appendChild(text)\n        mod.dzn = text\n        div.appendChild(info)\n    }\n    //\n    // local functions\n    //\n    // read handler\n    //\n    function stl_read_handler(event) {\n        var file_reader = new FileReader()\n        file_reader.onload = stl_load_handler\n        input_file = mod.file.files[0]\n        file_name = input_file.name\n        mod.namen.nodeValue = 'name: ' + file_name\n        file_reader.readAsArrayBuffer(input_file)\n    }\n    //\n    // load handler\n    //\n    function stl_load_handler(event) {\n        //\n        // check for binary STL\n        //\n        var endian = true\n        var view = new DataView(event.target.result)\n        var triangles = view.getUint32(80, endian)\n        var size = 80 + 4 + triangles * (4 * 12 + 2)\n        if (size != view.byteLength) {\n            mod.sizen.nodeValue = 'error: not binary STL'\n            mod.trianglesn.nodeValue = ''\n            mod.dxn.nodeValue = ''\n            mod.dyn.nodeValue = ''\n            mod.dzn.nodeValue = ''\n            return\n        }\n        mod.sizen.nodeValue = 'size: ' + size\n        mod.trianglesn.nodeValue = 'triangles: ' + triangles\n        //\n        // find limits and draw\n        //\n        var blob = new Blob(['(' + draw_limits_worker.toString() + '())'])\n        var url = window.URL.createObjectURL(blob)\n        var webworker = new Worker(url)\n        webworker.addEventListener('message', function(evt) {\n            //\n            // worker response\n            //\n            window.URL.revokeObjectURL(url)\n            //\n            // size\n            //\n            mod.dxn.nodeValue = 'dx: ' + evt.data.dx.toFixed(3)\n            mod.dyn.nodeValue = 'dy: ' + evt.data.dy.toFixed(3)\n            mod.dzn.nodeValue = 'dz: ' + evt.data.dz.toFixed(3)\n            //\n            // image\n            //\n            var image = evt.data.image\n            var height = mod.canvas.height\n            var width = mod.canvas.width\n            var buffer = new Uint8ClampedArray(evt.data.image)\n            var imgdata = new ImageData(buffer, width, height)\n            var ctx = mod.canvas.getContext(\"2d\")\n            ctx.putImageData(imgdata, 0, 0)\n            //\n            // output\n            //\n            outputs.mesh.event(evt.data.mesh)\n        })\n        var ctx = mod.canvas.getContext(\"2d\")\n        ctx.clearRect(0, 0, mod.canvas.width, mod.canvas.height)\n        var img = ctx.getImageData(0, 0, mod.canvas.width, mod.canvas.height)\n        //\n        // call worker\n        //\n        webworker.postMessage({\n            height: mod.canvas.height,\n            width: mod.canvas.width,\n            image: img.data.buffer,\n            mesh: event.target.result\n        }, [img.data.buffer, event.target.result])\n    }\n\n    function draw_limits_worker() {\n        self.addEventListener('message', function(evt) {\n            //\n            // function to draw line\n            //\n            function line(x0, y0, x1, y1) {\n                var ix0 = Math.floor(xo + xw * (x0 - xmin) / dx)\n                var iy0 = Math.floor(yo + yh * (ymax - y0) / dy)\n                var ix1 = Math.floor(xo + xw * (x1 - xmin) / dx)\n                var iy1 = Math.floor(yo + yh * (ymax - y1) / dy)\n                var row, col\n                var idx = ix1 - ix0\n                var idy = iy1 - iy0\n                if (Math.abs(idy) > Math.abs(idx)) {\n                    (idy > 0) ?\n                    (row0 = iy0, col0 = ix0, row1 = iy1, col1 = ix1) :\n                    (row0 = iy1, col0 = ix1, row1 = iy0, col1 = ix0)\n                    for (row = row0; row <= row1; ++row) {\n                        col = Math.floor(col0 + (col1 - col0) * (row - row0) / (row1 - row0))\n                        image[row * width * 4 + col * 4 + 0] = 0\n                        image[row * width * 4 + col * 4 + 1] = 0\n                        image[row * width * 4 + col * 4 + 2] = 0\n                        image[row * width * 4 + col * 4 + 3] = 255\n                    }\n                } else if ((Math.abs(idx) >= Math.abs(idy)) && (idx != 0)) {\n                    (idx > 0) ?\n                    (row0 = iy0, col0 = ix0, row1 = iy1, col1 = ix1) :\n                    (row0 = iy1, col0 = ix1, row1 = iy0, col1 = ix0)\n                    for (col = col0; col <= col1; ++col) {\n                        row = Math.floor(row0 + (row1 - row0) * (col - col0) / (col1 - col0))\n                        image[row * width * 4 + col * 4 + 0] = 0\n                        image[row * width * 4 + col * 4 + 1] = 0\n                        image[row * width * 4 + col * 4 + 2] = 0\n                        image[row * width * 4 + col * 4 + 3] = 255\n                    }\n                } else {\n                    row = iy0\n                    col = ix0\n                    image[row * width * 4 + col * 4 + 0] = 0\n                    image[row * width * 4 + col * 4 + 1] = 0\n                    image[row * width * 4 + col * 4 + 2] = 0\n                    image[row * width * 4 + col * 4 + 3] = 255\n                }\n            }\n            //\n            // get variables\n            //\n            var height = evt.data.height\n            var width = evt.data.width\n            var endian = true\n            var image = new Uint8ClampedArray(evt.data.image)\n            var view = new DataView(evt.data.mesh)\n            var triangles = view.getUint32(80, endian)\n            //\n            // find limits\n            //\n            var offset = 80 + 4\n            var x0, x1, x2, y0, y1, y2, z0, z1, z2\n            var xmin = Number.MAX_VALUE\n            var xmax = -Number.MAX_VALUE\n            var ymin = Number.MAX_VALUE\n            var ymax = -Number.MAX_VALUE\n            var zmin = Number.MAX_VALUE\n            var zmax = -Number.MAX_VALUE\n            for (var t = 0; t < triangles; ++t) {\n                offset += 3 * 4\n                x0 = view.getFloat32(offset, endian)\n                offset += 4\n                if (x0 > xmax) xmax = x0\n                if (x0 < xmin) xmin = x0\n                y0 = view.getFloat32(offset, endian)\n                offset += 4\n                if (y0 > ymax) ymax = y0\n                if (y0 < ymin) ymin = y0\n                z0 = view.getFloat32(offset, endian)\n                offset += 4\n                if (z0 > zmax) zmax = z0\n                if (z0 < zmin) zmin = z0\n                x1 = view.getFloat32(offset, endian)\n                offset += 4\n                if (x1 > xmax) xmax = x1\n                if (x1 < xmin) xmin = x1\n                y1 = view.getFloat32(offset, endian)\n                offset += 4\n                if (y1 > ymax) ymax = y1\n                if (y1 < ymin) ymin = y1\n                z1 = view.getFloat32(offset, endian)\n                offset += 4\n                if (z1 > zmax) zmax = z1\n                if (z1 < zmin) zmin = z1\n                x2 = view.getFloat32(offset, endian)\n                offset += 4\n                if (x2 > xmax) xmax = x2\n                if (x2 < xmin) xmin = x2\n                y2 = view.getFloat32(offset, endian)\n                offset += 4\n                if (y2 > ymax) ymax = y2\n                if (y2 < ymin) ymin = y2\n                z2 = view.getFloat32(offset, endian)\n                offset += 4\n                if (z2 > zmax) zmax = z2\n                if (z2 < zmin) zmin = z2\n                offset += 2\n            }\n            var dx = xmax - xmin\n            var dy = ymax - ymin\n            var dz = zmax - zmin\n            //\n            // draw mesh\n            //\n            if (dx > dy) {\n                var xo = 0\n                var yo = height * .5 * (1 - dy / dx)\n                var xw = width - 1\n                var yh = (width - 1) * dy / dx\n            } else {\n                var xo = width * .5 * (1 - dx / dy)\n                var yo = 0\n                var xw = (height - 1) * dx / dy\n                var yh = height - 1\n            }\n            offset = 80 + 4\n            for (var t = 0; t < triangles; ++t) {\n                offset += 3 * 4\n                x0 = view.getFloat32(offset, endian)\n                offset += 4\n                y0 = view.getFloat32(offset, endian)\n                offset += 4\n                z0 = view.getFloat32(offset, endian)\n                offset += 4\n                x1 = view.getFloat32(offset, endian)\n                offset += 4\n                y1 = view.getFloat32(offset, endian)\n                offset += 4\n                z1 = view.getFloat32(offset, endian)\n                offset += 4\n                x2 = view.getFloat32(offset, endian)\n                offset += 4\n                y2 = view.getFloat32(offset, endian)\n                offset += 4\n                z2 = view.getFloat32(offset, endian)\n                offset += 4\n                offset += 2\n                line(x0, y0, x1, y1)\n                line(x1, y1, x2, y2)\n                line(x2, y2, x0, y0)\n            }\n            //\n            // return results and close\n            //\n            self.postMessage({\n                dx: dx,\n                dy: dy,\n                dz: dz,\n                image: evt.data.image,\n                mesh: evt.data.mesh\n            }, [evt.data.image, evt.data.mesh])\n            self.close()\n        })\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"775.8927010700597","left":"600.4294504637375","inputs":{},"outputs":{}},"0.6999841802960824":{"definition":"//\n// Othermill/Bantam Tools milling machine\n//\n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2016\n// Modified by Francisco Sanchez Arroyo 13-May-2020\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'Othermill / Bantam Tools'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.speed.value = 4 // mm/s\n        mod.plunge.value = 2 // mm/s\n        mod.spindle_speed.value = 16400 // rpm\n        mod.tool = 1 // tool tumber\n        mod.ox.value = 0.0 // x offset mm\n        mod.oy.value = 0.0 // y offset mm\n        mod.jz.value = 2 // jog height mm\n        mod.tz.value = 0.0 // zero plate thickness in mm\n    }\n    //\n    // inputs\n    //\n    var inputs = {\n        path: {\n            type: '',\n            event: function(evt) {\n                mod.name = evt.detail.name\n                mod.path = evt.detail.path\n                mod.dpi = evt.detail.dpi\n                mod.width = evt.detail.width\n                mod.height = evt.detail.height\n                make_path()\n            }\n        }\n    }\n    //\n    // outputs\n    //\n    var outputs = {\n        file: {\n            type: '',\n            event: function(obj) {\n                mods.output(mod, 'file', obj)\n            }\n        }\n    }\n    //\n    // interface\n    //\n\n    var interface = function(div) {\n        mod.div = div\n        div.appendChild(document.createTextNode('job parameters:'))\n        div.appendChild(document.createElement('br'))\n        //\n        // speed\n        //\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0cut speed: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        div.appendChild(input)\n        mod.speed = input\n        div.appendChild(document.createTextNode(' (mm/s)'))\n        div.appendChild(document.createElement('br'))\n        //\n        // plunge speed\n        //\n        div.appendChild(document.createTextNode('plunge speed: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        div.appendChild(input)\n        mod.plunge = input\n        div.appendChild(document.createTextNode(' (mm/s)'))\n        div.appendChild(document.createElement('br'))\n        //\n        // jog\n        //\n        div.appendChild(document.createTextNode('\\u00a0jog height: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        div.appendChild(input)\n        mod.jz = input\n        div.appendChild(document.createTextNode(' (mm)\\u00a0'))\n        div.appendChild(document.createElement('br'))\n\n        //\n        // spindle speed\n        //\n        div.appendChild(document.createTextNode('spindle speed: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        div.appendChild(input)\n        mod.spindle_speed = input\n        div.appendChild(document.createTextNode(' (rpm)\\u00a0\\u00a0'))\n        //div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0'))\n        div.appendChild(document.createElement('br'))\n\n        div.appendChild(document.createElement('hr'))\n\n        //\n        // home\n        //\n        div.appendChild(document.createTextNode('home:'))\n        div.appendChild(document.createElement('br'))\n\n\n        var btn = document.createElement('button')\n        btn.style.padding = mods.ui.padding\n        btn.style.margin = 1\n        var span = document.createElement('span')\n        var text = document.createTextNode('auto home XYZ')\n        span.appendChild(text)\n        btn.appendChild(span)\n        btn.addEventListener('click', function() {\n            var str = \"G28.2 X0 Y0 Z0\\n\";\n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            outputs.file.event(obj)\n        })\n        div.appendChild(btn)\n\n        var btn = document.createElement('button')\n        btn.style.padding = mods.ui.padding\n        btn.style.margin = 1\n        var span = document.createElement('span')\n        var text = document.createTextNode('Probe Z0 Plate')\n        span.appendChild(text)\n        btn.appendChild(span)\n        btn.addEventListener('click', function() {\n            var warn = confirm(\"Warning: Make sure that the zero plate is over the material and is grounded to the machine\")\n            if (warn == true) {\n                var jog_height = parseFloat(mod.jz.value)\n                var zero_plate = parseFloat(mod.tz.value)\n                var str = \"G91\\n\"\n                str += \"G38.2 Z-70 F90\\n\"\n                str += \"G90\\n\"\n                str += \"G10 L20 P2 Z\" + zero_plate + \"\\n\"\n                str += \"G91\\n\"\n                str += \"G0 Z\" + jog_height + \"\\n\"\n                str += \"G90\\n\"\n                var obj = {}\n                obj.type = 'command'\n                obj.name = mod.name + '.nc'\n                obj.contents = str\n                outputs.file.event(obj)\n            } // end if\n        })\n        div.appendChild(btn)\n\n        div.appendChild(document.createElement('br'))\n\n        div.appendChild(document.createTextNode('\\u00a0zero plate thickness: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        div.appendChild(input)\n        mod.tz = input\n        div.appendChild(document.createTextNode(' (mm)'))\n        div.appendChild(document.createElement('hr'))\n\n        //\n        // origin x (mm)\n        //\n        div.appendChild(document.createTextNode('custom origin:'))\n        div.appendChild(document.createElement('br'))\n        div.appendChild(document.createTextNode('x: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        div.appendChild(input)\n        mod.ox = input\n        div.appendChild(document.createTextNode(' (mm)'))\n        div.appendChild(document.createElement('br'))\n        div.appendChild(document.createTextNode(' y: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        div.appendChild(input)\n        mod.oy = input\n        div.appendChild(document.createTextNode(' (mm)'))\n        div.appendChild(document.createElement('br'))\n\n        var btn = document.createElement('button')\n        btn.style.padding = mods.ui.padding\n        btn.style.margin = 1\n        var span = document.createElement('span')\n        var text = document.createTextNode('move to custom origin')\n        span.appendChild(text)\n        btn.appendChild(span)\n        btn.addEventListener('click', function() {\n            var x0 = parseFloat(mod.ox.value)\n            var y0 = parseFloat(mod.oy.value)\n            var z0 = 0\n            var zjog = parseFloat(mod.jz.value)\n            var str = \" G55 G90 G0 X\" + x0 + \" Y\" + y0 + \"\\n\" // go to x0 y0 in abs coordinates \n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            outputs.file.event(obj)\n        })\n        div.appendChild(btn)\n        div.appendChild(document.createElement('hr'))\n\n\n\n\n\n\n        //\n        // manual move buttons\n        //\n        div.appendChild(document.createTextNode('manual move:'))\n        div.appendChild(document.createElement('br'))\n\n        var input = document.createElement('input')\n        input.type = 'radio'\n        input.name = mod.div.id + 'range'\n        input.id = mod.div.id + 'range_big'\n        div.appendChild(input)\n        mod.range_big = input\n        div.appendChild(document.createTextNode('5mm'))\n        var input = document.createElement('input')\n        input.type = 'radio'\n        input.name = mod.div.id + 'range'\n        input.id = mod.div.id + 'range_medium'\n        div.appendChild(input)\n        mod.range_medium = input\n        mod.range_medium.checked = true\n        div.appendChild(document.createTextNode('1mm'))\n        var input = document.createElement('input')\n        input.type = 'radio'\n        input.name = mod.div.id + 'range'\n        input.id = mod.div.id + 'range_small'\n        div.appendChild(input)\n        mod.range_small = input\n        div.appendChild(document.createTextNode('0.1mm'))\n        div.appendChild(document.createElement('br'))\n        div.appendChild(document.createElement('br'))\n\n\n\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0'))\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('+ Y'))\n        btn.addEventListener('click', function() {\n            //\n            // Check step\n            //\n            check_step()\n            //\n            // Create message\n            //\n            var str = \"G91 G21 G0 Y\" + mod.step + \"\\n\"\n            //\n            // send command\n            //\n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            mods.output(mod, 'file', obj)\n        })\n        div.appendChild(btn)\n\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0'))\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('+Z'))\n        btn.addEventListener('click', function() {\n            //\n            // Check step\n            //\n            check_step()\n            //\n            // Create message\n            //\n            var str = \"G91 G21 G0 Z\" + mod.step + \"\\n\"\n            //\n            // send command\n            //\n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            mods.output(mod, 'file', obj)\n        })\n        div.appendChild(btn)\n\n        div.appendChild(document.createElement('br'))\n\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0'))\n\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('-X'))\n        btn.addEventListener('click', function() {\n            //\n            // Check step\n            //\n            check_step()\n            //\n            // Create message\n            //\n            var str = \"G91 G21 G0 X-\" + mod.step + \"\\n\"\n            //\n            // send command\n            //\n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            mods.output(mod, 'file', obj)\n        })\n        div.appendChild(btn)\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('XY0'))\n        btn.addEventListener('click', function() {\n            var warn = confirm(\"Warning: This will set the new zero for the X and Y axis\")\n            if (warn == true) {\n                //\n                // Check step\n                //\n                check_step()\n                //\n                // Create message\n                //\n                var str = \"G28.3 X0 Y0\\n\"\n                //\n                // send command\n                //\n                var obj = {}\n                obj.type = 'command'\n                obj.name = mod.name + '.nc'\n                obj.contents = str\n                mods.output(mod, 'file', obj)\n            } // close if\n        })\n        div.appendChild(btn)\n\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('+X'))\n        btn.addEventListener('click', function() {\n            //\n            // Check step\n            //\n            check_step()\n            //\n            // Create message\n            //\n            var str = \"G91 G21 G0 X\" + mod.step + \"\\n\"\n            //\n            // send command\n            //\n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            mods.output(mod, 'file', obj)\n        })\n        div.appendChild(btn)\n\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0'))\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('Z0'))\n        btn.addEventListener('click', function() {\n            var warn = confirm(\"Warning: This will set the new zero for the Z axis\")\n            if (warn == true) {\n                //\n                // Create message\n                //\n                var str = \"G28.3 Z0\\n\"\n                //\n                // send command\n                //\n                var obj = {}\n                obj.type = 'command'\n                obj.name = mod.name + '.nc'\n                obj.contents = str\n                mods.output(mod, 'file', obj)\n            } // close if\n        })\n        div.appendChild(btn)\n\n\n        div.appendChild(document.createElement('br'))\n\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0'))\n\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('- Y'))\n        btn.addEventListener('click', function() {\n            //\n            // Check step\n            //\n            check_step()\n            //\n            // Create message\n            //\n            var str = \"G91 G21 G0 Y-\" + mod.step + \"\\n\"\n            //\n            // send command\n            //\n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            mods.output(mod, 'file', obj)\n        })\n        div.appendChild(btn)\n\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0'))\n\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('-Z'))\n        btn.addEventListener('click', function() {\n            //\n            // Check step\n            //\n            check_step()\n            //\n            // Create message\n            //\n            var str = \"G91 G21 G0 Z-\" + mod.step + \"\\n\"\n            //\n            // send command\n            //\n            var obj = {}\n            obj.type = 'command'\n            obj.name = mod.name + '.nc'\n            obj.contents = str\n            mods.output(mod, 'file', obj)\n        })\n        div.appendChild(btn)\n\n\n\n    }\n    //\n    // local functions\n    //\n\n    function check_step() {\n        //\n        // Checks how big is the manual move step \n        // Units are mm\n        //\n        if (mod.range_big.checked) {\n            mod.step = 5\n        } else if (mod.range_medium.checked) {\n            mod.step = 1\n        } else if (mod.range_small.checked) {\n            mod.step = 0.1\n        }\n    }\n\n\n\n\n    function make_path() {\n        var dx = 25.4 * mod.width / mod.dpi\n        var nx = mod.width\n        var cut_speed = 60 * parseFloat(mod.speed.value) // check units input should be mm/s and output is mm/min\n        var plunge_speed = 60 * parseFloat(mod.plunge.value) // check units input should be mm/s\n        var jog_height = parseFloat(mod.jz.value) // input in mm\n        var spindle_speed = parseFloat(mod.spindle_speed.value)\n        var tool = mod.tool\n        var scale = dx / (nx - 1)\n        var x0 = parseFloat(mod.ox.value)\n        var y0 = parseFloat(mod.oy.value)\n        var z0 = 0\n        var xoffset = x0\n        var yoffset = y0\n        var zoffset = z0\n        str = \"%\\n\" // tape start\n        // Clear all state: XY plane, inch mode, cancel diameter compensation, cancel length offset\n        // coordinate system 2, cancel motion, non-incremental motion, feed/minute mode\n        str += \"G17\\n\" // select XY plane\n        str += \"G21\\n\" // mm mode\n        str += \"G40\\n\" // cancel diameter compensation\n        str += \"G49\\n\" // cancel tool length compensation\n        // Othermill assumes G55 coordinate system\n        str += \"G55\\n\" // custom coordinate system 2\n        str += \"G80\\n\" // stop axis movement\n        str += \"G90\\n\" // non incremental motion\n        str += \"G94\\n\" // feed rate mode: units per minute\n        str += \"T\" + tool + \"M06\\n\" // tool selection, tool change\n        str += \"F\" + cut_speed.toFixed(4) + \"\\n\" // feed rate\n        str += \"S\" + spindle_speed + \"\\n\" // spindle speed\n        str += \"G00Z\" + jog_height.toFixed(4) + \"\\n\" // move up before starting spindle\n        str += \"M03\\n\" // spindle on clockwise\n        str += \"G04 P1\\n\" // give spindle 1 second to spin up\n        //\n        // follow segments\n        //\n        for (var seg = 0; seg < mod.path.length; ++seg) {\n            var x = xoffset + scale * mod.path[seg][0][0]\n            var y = yoffset + scale * mod.path[seg][0][1]\n            var z = zoffset + scale * mod.path[seg][0][2]\n            //\n            // move up to starting point\n            //\n            str += \"Z\" + jog_height.toFixed(4) + \"\\n\"\n            str += \"G00X\" + x.toFixed(4) + \"Y\" + y.toFixed(4) + \"Z\" + jog_height.toFixed(4) + \"\\n\"\n            //\n            // move down\n            //\n            str += \"G01Z\" + z.toFixed(4) + \" F\" + plunge_speed.toFixed(4) + \"\\n\"\n            str += \"F\" + cut_speed.toFixed(4) + \"\\n\" //restore XY feed rate\n            for (var pt = 1; pt < mod.path[seg].length; ++pt) {\n                //\n                // move to next point\n                //\n                x = xoffset + scale * mod.path[seg][pt][0]\n                y = yoffset + scale * mod.path[seg][pt][1]\n                z = zoffset + scale * mod.path[seg][pt][2]\n                str += \"G01X\" + x.toFixed(4) + \"Y\" + y.toFixed(4) + \"Z\" + z.toFixed(4) + \"\\n\"\n            }\n        }\n        //\n        // finish\n        //\n        str += \"G00Z\" + jog_height.toFixed(4) + \"\\n\" // move up before stopping spindle\n        str += \"M05\\n\" // spindle stop\n        str += \"M30\\n\" // program end and reset\n        str += \"%\\n\" // tape end\n\n\n\n\n        //\n        // output string\n        //\n        var obj = {}\n        obj.type = 'file'\n        obj.name = mod.name + '.nc'\n        obj.contents = str\n        outputs.file.event(obj)\n\n    }\n    //\n    // return values\n    //\n    return ({\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"1300.2448613324416","left":"3180.2247298598795","inputs":{},"outputs":{}},"0.3244175934978727":{"definition":"//\n// label\n//\n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2018\n// Modified by Francisco Sanchez Arroyo 02-Feb-2020\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'label'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.size.value = '400'\n        mod.text.value = 'Othermill / Bantam Tools wax'\n        update_text()\n    }\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {}\n    //\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //div.appendChild(document.createTextNode('font size: '))\n        input = document.createElement('input')\n        input.type = 'text'\n        input.size = 3\n        input.addEventListener('input', function(evt) {\n            update_text()\n        })\n        //div.appendChild(input)\n        mod.size = input\n        //div.appendChild(document.createTextNode(' (%)'))\n        //div.appendChild(document.createElement('br'))\n        //div.appendChild(document.createTextNode('text: '))\n        input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        input.addEventListener('input', function(evt) {\n            update_text()\n        })\n        //div.appendChild(input)\n        mod.text = input\n        //div.appendChild(document.createElement('br'))\n        var span = document.createElement('span')\n        var text = document.createTextNode('')\n        span.appendChild(text)\n        mod.label = text\n        div.appendChild(span)\n        mod.span = span\n    }\n    //\n    // local functions\n    //\n    function update_text() {\n        mod.label.nodeValue = mod.text.value\n        mod.span.style.fontSize = mod.size.value + '%'\n        mods.fit(mod.div)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"439.60141616024464","left":"901.6578934942888","inputs":{},"outputs":{}},"0.9712638252399309":{"definition":"//\n// mesh height map\n// \n// Neil Gershenfeld 1/16/20\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'mesh height map'\n//\n// initialization\n//\nvar init = function() {\n   mod.mmunits.value = '25.4'\n   mod.inunits.value = '1'\n   mod.width.value = '1000'\n   mod.border.value = '0'\n   }\n//\n// inputs\n//\nvar inputs = {\n   mesh:{type:'STL',\n      event:function(evt){\n         mod.mesh = new DataView(evt.detail)\n         find_limits_map()}}}\n//\n// outputs\n//\nvar outputs = {\n   map:{type:'',label:'height map',\n      event:function(heightmap){\n         var obj = {}\n         obj.map = heightmap\n         obj.xmin = mod.xmin\n         obj.xmax = mod.xmax\n         obj.ymin = mod.ymin\n         obj.ymax = mod.ymax\n         obj.zmin = mod.zmin\n         obj.zmax = mod.zmax\n         obj.width = mod.img.width\n         obj.height = mod.img.height\n         obj.mmunits = mod.mmunits.value\n         mods.output(mod,'map',obj)\n         }}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen height map canvas\n   //\n   div.appendChild(document.createTextNode(' '))\n   var canvas = document.createElement('canvas')\n      canvas.width = mods.ui.canvas\n      canvas.height = mods.ui.canvas\n      canvas.style.backgroundColor = 'rgb(255,255,255)'\n      div.appendChild(canvas)\n      mod.mapcanvas = canvas\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // mesh units\n   //\n   div.appendChild(document.createTextNode('mesh units: (enter)'))\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mm: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         mod.inunits.value = parseFloat(mod.mmunits.value)/25.4\n         find_limits_map()\n         })\n      div.appendChild(input)\n      mod.mmunits = input\n   div.appendChild(document.createTextNode(' in: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         mod.mmunits.value = parseFloat(mod.inunits.value)*25.4\n         find_limits_map()\n         })\n      div.appendChild(input)\n      mod.inunits = input\n   //\n   // mesh size\n   //\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mesh size:'))\n   div.appendChild(document.createElement('br'))\n   var text = document.createTextNode('XxYxZ (units)')\n      div.appendChild(text)\n      mod.meshsize = text\n   div.appendChild(document.createElement('br'))\n   var text = document.createTextNode('XxYxZ (mm)')\n      div.appendChild(text)\n      mod.mmsize = text\n   div.appendChild(document.createElement('br'))\n   var text = document.createTextNode('XxYxZ (in)')\n      div.appendChild(text)\n      mod.insize = text\n   //\n   // height map border \n   //\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('border: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         find_limits_map()\n         })\n      div.appendChild(input)\n      mod.border = input\n   div.appendChild(document.createTextNode(' (units)'))\n   //\n   // height map width\n   //\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('width: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         find_limits_map()\n         })\n      div.appendChild(input)\n      mod.width = input\n   div.appendChild(document.createTextNode(' (pixels)'))\n   //\n   // view height map\n   //\n   div.appendChild(document.createElement('br'))\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view height map'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var canvas = document.createElement('canvas')\n            canvas.width = mod.img.width\n            canvas.height = mod.img.height\n            win.document.body.appendChild(canvas)\n         var ctx = canvas.getContext(\"2d\")\n            ctx.drawImage(mod.img,0,0)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// find limits then map \n//\nfunction find_limits_map() {\n   var blob = new Blob(['('+limits_worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      mod.triangles = evt.data.triangles\n      mod.xmin = evt.data.xmin\n      mod.xmax = evt.data.xmax\n      mod.ymin = evt.data.ymin\n      mod.ymax = evt.data.ymax\n      mod.zmin = evt.data.zmin\n      mod.zmax = evt.data.zmax\n      mod.dx = mod.xmax-mod.xmin\n      mod.dy = mod.ymax-mod.ymin\n      mod.dz = mod.zmax-mod.zmin\n      mod.meshsize.nodeValue = \n         mod.dx.toFixed(3)+' x '+\n         mod.dy.toFixed(3)+' x '+\n         mod.dz.toFixed(3)+' (units)'\n      var mm = parseFloat(mod.mmunits.value)\n      mod.mmsize.nodeValue = \n         (mod.dx*mm).toFixed(3)+' x '+\n         (mod.dy*mm).toFixed(3)+' x '+\n         (mod.dz*mm).toFixed(3)+' (mm)'\n      var inches = parseFloat(mod.inunits.value)\n      mod.insize.nodeValue = \n         (mod.dx*inches).toFixed(3)+' x '+\n         (mod.dy*inches).toFixed(3)+' x '+\n         (mod.dz*inches).toFixed(3)+' (in)'\n      mods.fit(mod.div)\n      map_mesh()\n      })\n   var border = parseFloat(mod.border.value)\n   webworker.postMessage({\n      mesh:mod.mesh,\n      border:border})\n   }\nfunction limits_worker() {\n   self.addEventListener('message',function(evt) {\n      var view = evt.data.mesh\n      var border = evt.data.border\n      //\n      // get vars\n      //\n      var endian = true\n      var triangles = view.getUint32(80,endian)\n      var size = 80+4+triangles*(4*12+2)\n      //\n      // find limits\n      //\n      var offset = 80+4\n      var x0,x1,x2,y0,y1,y2,z0,z1,z2\n      var xmin = Number.MAX_VALUE\n      var xmax = -Number.MAX_VALUE\n      var ymin = Number.MAX_VALUE\n      var ymax = -Number.MAX_VALUE\n      var zmin = Number.MAX_VALUE\n      var zmax = -Number.MAX_VALUE\n      for (var t = 0; t < triangles; ++t) {\n         offset += 3*4\n         x0 = view.getFloat32(offset,endian)\n         offset += 4\n         y0 = view.getFloat32(offset,endian)\n         offset += 4\n         z0 = view.getFloat32(offset,endian)\n         offset += 4\n         x1 = view.getFloat32(offset,endian)\n         offset += 4\n         y1 = view.getFloat32(offset,endian)\n         offset += 4\n         z1 = view.getFloat32(offset,endian)\n         offset += 4\n         x2 = view.getFloat32(offset,endian)\n         offset += 4\n         y2 = view.getFloat32(offset,endian)\n         offset += 4\n         z2 = view.getFloat32(offset,endian)\n         offset += 4\n         offset += 2\n         if (x0 > xmax) xmax = x0\n         if (x0 < xmin) xmin = x0\n         if (y0 > ymax) ymax = y0\n         if (y0 < ymin) ymin = y0\n         if (z0 > zmax) zmax = z0\n         if (z0 < zmin) zmin = z0\n         if (x1 > xmax) xmax = x1\n         if (x1 < xmin) xmin = x1\n         if (y1 > ymax) ymax = y1\n         if (y1 < ymin) ymin = y1\n         if (z1 > zmax) zmax = z1\n         if (z1 < zmin) zmin = z1\n         if (x2 > xmax) xmax = x2\n         if (x2 < xmin) xmin = x2\n         if (y2 > ymax) ymax = y2\n         if (y2 < ymin) ymin = y2\n         if (z2 > zmax) zmax = z2\n         if (z2 < zmin) zmin = z2\n         }\n      xmin -= border\n      xmax += border\n      ymin -= border\n      ymax += border\n      //\n      // return\n      //\n      self.postMessage({triangles:triangles,\n         xmin:xmin,xmax:xmax,ymin:ymin,ymax:ymax,\n         zmin:zmin,zmax:zmax})\n      self.close()\n      })\n   }\n//\n// map mesh\n//   \nfunction map_mesh() {\n   var blob = new Blob(['('+map_worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      var h = mod.img.height\n      var w = mod.img.width\n      var buf = new Uint8ClampedArray(evt.data.imgbuffer)\n      var map = new Float32Array(evt.data.mapbuffer)\n      var imgdata = new ImageData(buf,w,h)\n      var ctx = mod.img.getContext(\"2d\")\n      ctx.putImageData(imgdata,0,0)\n      if (w > h) {\n         var x0 = 0\n         var y0 = mod.mapcanvas.height*.5*(1-h/w)\n         var wd = mod.mapcanvas.width\n         var hd = mod.mapcanvas.width*h/w\n         }\n      else {\n         var x0 = mod.mapcanvas.width*.5*(1-w/h)\n         var y0 = 0\n         var wd = mod.mapcanvas.height*w/h\n         var hd = mod.mapcanvas.height\n         }\n      var ctx = mod.mapcanvas.getContext(\"2d\")\n      ctx.clearRect(0,0,mod.mapcanvas.width,mod.mapcanvas.height)\n      ctx.drawImage(mod.img,x0,y0,wd,hd)\n      outputs.map.event(map)\n      })\n   var ctx = mod.mapcanvas.getContext(\"2d\")\n   ctx.clearRect(0,0,mod.mapcanvas.width,mod.mapcanvas.height)\n   mod.img.width = parseInt(mod.width.value)\n   mod.img.height = Math.round(mod.img.width*mod.dy/mod.dx)\n   var ctx = mod.img.getContext(\"2d\")\n   var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n   var map = new Float32Array(mod.img.width*mod.img.height)\n   webworker.postMessage({\n      height:mod.img.height,width:mod.img.width,\n      imgbuffer:img.data.buffer,\n      mapbuffer:map.buffer,\n      mesh:mod.mesh,\n      xmin:mod.xmin,xmax:mod.xmax,\n      ymin:mod.ymin,ymax:mod.ymax,\n      zmin:mod.zmin,zmax:mod.zmax},\n      [img.data.buffer,map.buffer])\n   }\nfunction map_worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var view = evt.data.mesh\n      var xmin = evt.data.xmin\n      var xmax = evt.data.xmax\n      var ymin = evt.data.ymin\n      var ymax = evt.data.ymax\n      var zmin = evt.data.zmin\n      var zmax = evt.data.zmax\n      var buf = new Uint8ClampedArray(evt.data.imgbuffer)\n      var map = new Float32Array(evt.data.mapbuffer)\n      //\n      // get vars from buffer\n      //\n      var endian = true\n      var triangles = view.getUint32(80,endian)\n      var size = 80+4+triangles*(4*12+2)\n      //\n      // initialize map and image\n      //\n      for (var row = 0; row < h; ++row) {\n         for (var col = 0; col < w; ++col) {\n            map[(h-1-row)*w+col] = zmin\n            buf[(h-1-row)*w*4+col*4+0] = 0\n            buf[(h-1-row)*w*4+col*4+1] = 0\n            buf[(h-1-row)*w*4+col*4+2] = 0\n            buf[(h-1-row)*w*4+col*4+3] = 255\n            }\n         }\n      //\n      // loop over triangles\n      //\n      var segs = []\n      offset = 80+4\n      for (var t = 0; t < triangles; ++t) {\n         offset += 3*4\n         x0 = view.getFloat32(offset,endian)\n         offset += 4\n         y0 = view.getFloat32(offset,endian)\n         offset += 4\n         z0 = view.getFloat32(offset,endian)\n         offset += 4\n         x1 = view.getFloat32(offset,endian)\n         offset += 4\n         y1 = view.getFloat32(offset,endian)\n         offset += 4\n         z1 = view.getFloat32(offset,endian)\n         offset += 4\n         x2 = view.getFloat32(offset,endian)\n         offset += 4\n         y2 = view.getFloat32(offset,endian)\n         offset += 4\n         z2 = view.getFloat32(offset,endian)\n         offset += 4\n         offset += 2\n         //\n         // check normal if needs to be drawn\n         //\n         if (((x1-x0)*(y1-y2)-(x1-x2)*(y1-y0)) >= 0)\n            continue\n         //\n         // quantize image coordinates\n         //\n         x0 = Math.floor((w-1)*(x0-xmin)/(xmax-xmin))\n         x1 = Math.floor((w-1)*(x1-xmin)/(xmax-xmin))\n         x2 = Math.floor((w-1)*(x2-xmin)/(xmax-xmin))\n         y0 = Math.floor((h-1)*(y0-ymin)/(ymax-ymin))\n         y1 = Math.floor((h-1)*(y1-ymin)/(ymax-ymin))\n         y2 = Math.floor((h-1)*(y2-ymin)/(ymax-ymin))\n         //\n         // sort projection order\n         //\n         if (y1 > y2) {\n            var temp = x1;\n            x1 = x2;\n            x2 = temp\n            var temp = y1;\n            y1 = y2;\n            y2 = temp\n            var temp = z1;\n            z1 = z2;\n            z2 = temp\n            }\n         if (y0 > y1) {\n            var temp = x0;\n            x0 = x1;\n            x1 = temp\n            var temp = y0;\n            y0 = y1;\n            y1 = temp\n            var temp = z0;\n            z0 = z1;\n            z1 = temp\n            }\n         if (y1 > y2) {\n            var temp = x1;\n            x1 = x2;\n            x2 = temp\n            var temp = y1;\n            y1 = y2;\n            y2 = temp\n            var temp = z1;\n            z1 = z2;\n            z2 = temp\n            }\n         //\n         // check orientation after sort\n         //\n         if (x1 < (x0+((x2-x0)*(y1-y0))/(y2-y0)))\n            var dir = 1;\n         else\n            var dir = -1;\n         //\n         // set z values\n         //\n         if (y2 != y1) {\n            for (var y = y1; y <= y2; ++y) {\n               x12 = Math.floor(0.5+x1+(y-y1)*(x2-x1)/(y2-y1))\n               z12 = z1+(y-y1)*(z2-z1)/(y2-y1)\n               x02 = Math.floor(0.5+x0+(y-y0)*(x2-x0)/(y2-y0))\n               z02 = z0+(y-y0)*(z2-z0)/(y2-y0)\n               if (x12 != x02)\n                  var slope = (z02-z12)/(x02-x12)\n               else\n                  var slope = 0\n               var x = x12 - dir\n               while (x != x02) {\n                  x += dir\n                  var z = z12+slope*(x-x12)\n                  if (z > map[(h-1-y)*w+x]) {\n                     map[(h-1-y)*w+x] = z\n                     var iz = Math.floor(255*(z-zmin)/(zmax-zmin))\n                     buf[(h-1-y)*w*4+x*4+0] = iz\n                     buf[(h-1-y)*w*4+x*4+1] = iz\n                     buf[(h-1-y)*w*4+x*4+2] = iz\n                     }\n                  }\n               }\n            }\n         if (y1 != y0) {\n            for (var y = y0; y <= y1; ++y) {\n               x01 = Math.floor(0.5+x0+(y-y0)*(x1-x0)/(y1-y0))\n               z01 = z0+(y-y0)*(z1-z0)/(y1-y0)\n               x02 = Math.floor(0.5+x0+(y-y0)*(x2-x0)/(y2-y0))\n               z02 = z0+(y-y0)*(z2-z0)/(y2-y0)\n               if (x01 != x02)\n                  var slope = (z02-z01)/(x02-x01)\n               else\n                  var slope = 0\n               var x = x01 - dir\n               while (x != x02) {\n                  x += dir\n                  var z = z01+slope*(x-x01)\n                  if (z > map[(h-1-y)*w+x]) {\n                     map[(h-1-y)*w+x] = z\n                     var iz = Math.floor(255*(z-zmin)/(zmax-zmin))\n                     buf[(h-1-y)*w*4+x*4+0] = iz\n                     buf[(h-1-y)*w*4+x*4+1] = iz\n                     buf[(h-1-y)*w*4+x*4+2] = iz\n                     }\n                  }\n               }\n            }\n         }\n      //\n      // output the map\n      //\n      self.postMessage({imgbuffer:buf.buffer,mapbuffer:map.buffer},[buf.buffer,map.buffer])\n      self.close()\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"1232.6839566518365","left":"1561.4861874086357","inputs":{},"outputs":{}},"0.14496496987822938":{"definition":"//\n// mill raster 3D\n//\n// Neil Gershenfeld 1/18/20\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'mill raster 3D'\n//\n// initialization\n//\nvar init = function() {\n   mod.dia_in.value = '0.125'\n   mod.dia_mm.value = '3.175'\n   mod.stepover.value = '0.5'\n   mod.error.value = '0.001'\n   }\n//\n// inputs\n//\nvar inputs = {\n   map:{type:'',label:'height map',\n      event:function(evt){\n         mod.map = evt.detail.map\n         mod.xmin = evt.detail.xmin\n         mod.xmax = evt.detail.xmax\n         mod.ymin = evt.detail.ymin\n         mod.ymax = evt.detail.ymax\n         mod.zmin = evt.detail.zmin\n         mod.zmax = evt.detail.zmax\n         mod.width = evt.detail.width\n         mod.height = evt.detail.height\n         mod.depth = Math.floor((mod.zmax-mod.zmin)*mod.width/(mod.xmax-mod.xmin))\n         mod.mmunits = evt.detail.mmunits\n         mod.dpi = mod.width/(mod.mmunits*(mod.xmax-mod.xmin)/25.4)\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.width = mod.width\n         ctx.canvas.height = mod.height\n         }}}\n//\n// outputs\n//\nvar outputs = {\n   toolpath:{type:'',\n      event:function(){\n         obj = {}\n         obj.path = mod.path\n         obj.name = \"mill raster 3D\"\n         obj.dpi = mod.dpi\n         obj.width = mod.width\n         obj.height = mod.height\n         obj.depth = mod.depth\n         mods.output(mod,'toolpath',obj)\n         }}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // tool diameter\n   //\n   div.appendChild(document.createTextNode('tool diameter'))\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mm: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.dia_in.value = parseFloat(mod.dia_mm.value)/25.4\n         })\n      div.appendChild(input)\n      mod.dia_mm = input\n   div.appendChild(document.createTextNode(' in: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.dia_mm.value = parseFloat(mod.dia_in.value)*25.4\n         })\n      div.appendChild(input)\n      mod.dia_in = input\n   div.appendChild(document.createElement('br'))\n   //\n   // stepover\n   //\n   div.appendChild(document.createTextNode('stepover (0-1): '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      div.appendChild(input)\n      mod.stepover = input\n   div.appendChild(document.createElement('br'))\n   //\n   // tool shape\n   //\n   div.appendChild(document.createTextNode('tool shape: '))\n   var input = document.createElement('input')\n      input.type = 'radio'\n      input.name = mod.div.id+'shape'\n      input.id = mod.div.id+'flatend'\n      input.checked = true\n      div.appendChild(input)\n      mod.flatend= input\n   div.appendChild(document.createTextNode('flat end'))\n   div.appendChild(document.createElement('br'))\n   //\n   // direction \n   //\n   div.appendChild(document.createTextNode('direction: '))\n   var input = document.createElement('input')\n      input.type = 'radio'\n      input.name = mod.div.id+'direction'\n      input.id = mod.div.id+'dirx'\n      input.checked = true\n      div.appendChild(input)\n      mod.dirx = input\n   div.appendChild(document.createTextNode('xz'))\n   div.appendChild(document.createElement('br'))\n   //\n   // fit error \n   //\n   div.appendChild(document.createTextNode('vector fit: '))\n   //div.appendChild(document.createElement('br'))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      div.appendChild(input)\n      mod.error = input\n   div.appendChild(document.createElement('br'))\n   //\n   // calculate\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      var span = document.createElement('span')\n         var text = document.createTextNode('calculate')\n            mod.label = text\n            span.appendChild(text)\n         mod.labelspan = span\n         btn.appendChild(span)\n      btn.addEventListener('click',function(){\n         mod.label.nodeValue = 'calculating'\n         mod.labelspan.style.fontWeight = 'bold'\n         calculate_path()\n         })\n      div.appendChild(btn)\n   div.appendChild(document.createTextNode(' '))\n   //\n   // view\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var svg = document.getElementById(mod.div.id+'svg')\n         var clone = svg.cloneNode(true)\n         clone.setAttribute('width',mod.img.width)\n         clone.setAttribute('height',mod.img.height)\n         win.document.body.appendChild(clone)\n         })\n      div.appendChild(btn)\n   div.appendChild(document.createElement('br'))\n   //\n   // on-screen SVG\n   //\n   var svgNS = \"http://www.w3.org/2000/svg\"\n   var svg = document.createElementNS(svgNS,\"svg\")\n   svg.setAttribute('id',mod.div.id+'svg')\n   svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\",\n      \"xmlns:xlink\",\"http://www.w3.org/1999/xlink\")\n   svg.setAttribute('width',mods.ui.canvas)\n   svg.setAttribute('height',mods.ui.canvas)\n   svg.style.backgroundColor = 'rgb(255,255,255)'\n   var g = document.createElementNS(svgNS,'g')\n   g.setAttribute('id',mod.div.id+'g')\n   svg.appendChild(g)\n   div.appendChild(svg)\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   }\n//\n// local functions\n//\n// calculate path\n//\nfunction calculate_path() {\n   var blob = new Blob(['('+calculate_path_worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      if (evt.data.type == \"progress\") {\n         mod.label.nodeValue = evt.data.value\n         return\n         }\n      //\n      // webworker handler\n      //\n      mod.path = evt.data.path\n      mod.label.nodeValue = 'calculate'\n      mod.labelspan.style.fontWeight = 'normal'\n      //\n      // clear SVG\n      //\n      var svg = document.getElementById(mod.div.id+'svg')\n      svg.setAttribute('viewBox',\"0 0 \"+(mod.width-1)+\" \"+(mod.height-1))\n      var g = document.getElementById(mod.div.id+'g')\n      svg.removeChild(g)\n      var g = document.createElementNS('http://www.w3.org/2000/svg','g')\n      g.setAttribute('id',mod.div.id+'g')\n      svg.appendChild(g)\n      //\n      // plot path\n      //\n      for (var i = 1; i < mod.path[0].length; ++i) {\n         var ixp = mod.path[0][i-1][0]\n         var iyp = mod.height-1-mod.path[0][i-1][1]\n         var izp = 0.1*mod.path[0][i-1][2]\n         var ix = mod.path[0][i][0]\n         var iy = mod.height-1-mod.path[0][i][1]\n         var iz = 0.1*mod.path[0][i][2]\n         var line = document.createElementNS(\n               'http://www.w3.org/2000/svg','line')\n            line.setAttribute('stroke','black')\n            line.setAttribute('stroke-width',1)\n            line.setAttribute('stroke-linecap','round')\n            line.setAttribute('x1',ixp)\n            line.setAttribute('y1',iyp-izp)\n            line.setAttribute('x2',ix)\n            line.setAttribute('y2',iy-iz)\n            g.appendChild(line)\n            }\n      //\n      // output path\n      //\n      outputs.toolpath.event()\n      })\n   //\n   // call webworker\n   //\n   webworker.postMessage({\n      height:mod.height,width:mod.width,\n      error:mod.error.value,\n      xmin:mod.xmin,xmax:mod.xmax,\n      ymin:mod.ymin,ymax:mod.ymax,\n      zmin:mod.zmin,zmax:mod.zmax,\n      diameter:mod.dia_mm.value,\n      stepover:mod.stepover.value,\n      mmunits: mod.mmunits,\n      map:mod.map})\n   }\n//\n// calculate path worker\n//\nfunction calculate_path_worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var error = evt.data.error\n      var xmin = evt.data.xmin\n      var xmax = evt.data.xmax\n      var ymin = evt.data.ymin\n      var ymax = evt.data.ymax\n      var zmin = evt.data.zmin\n      var zmax = evt.data.zmax\n      var map = evt.data.map\n      var diameter = evt.data.diameter\n      var stepover = evt.data.stepover\n      var mmunits = evt.data.mmunits\n      var ystep = Math.floor(stepover*diameter*w/(mmunits*(xmax-xmin)))\n      var path = [[]]\n      //\n      // construct tool offset\n      //\n      var toolsize = Math.floor(diameter*w/(mmunits*(xmax-xmin)))\n      var tooloffset = new Float32Array(toolsize*toolsize)\n      var toolmiddle = Math.floor(toolsize/2)\n      for (var x = 0; x < toolsize; ++x)\n         for (var y = 0; y < toolsize; ++y) {\n            var r = Math.sqrt((x-toolmiddle)*(x-toolmiddle)+(y-toolmiddle)*(y-toolmiddle))\n            if (r <= toolmiddle)\n               tooloffset[y*toolsize+x] = 0\n            else\n               tooloffset[y*toolsize+x] = Number.MAX_VALUE\n            }\n      //\n      // loop over lines\n      //\n      var xstart = 0\n      var ystart = h-1\n      var zstart = Math.floor((map[ystart*w+xstart]-zmax)*w/(xmax-xmin))\n      path[0].push([xstart,h-1-ystart,zstart])\n      var xcur = 1\n      var ycur = h-1\n      var zcur = Math.floor((map[ycur*w+xcur]-zmax)*w/(xmax-xmin))\n      var dx = 1\n      var dy = 0\n      while (1) {\n         //\n         // move to next point\n         //\n         xnext = xcur+dx\n         ynext = ycur+dy\n         if (ynext <= 0)\n            //\n            // done\n            //\n            break;\n         //\n         // find offset at next point\n         //\n         var znext = -Number.MAX_VALUE\n         for (var xoffset = 0; xoffset < toolsize; ++xoffset)\n            for (var yoffset = 0; yoffset < toolsize; ++yoffset) {\n               var x = xnext+(xoffset-toolmiddle)\n               var y = ynext+(yoffset-toolmiddle)\n               var offset = tooloffset[yoffset*toolsize+xoffset]\n               var z = Math.floor((map[y*w+x]-zmax)*w/(xmax-xmin))-offset\n               if (z > znext)\n                  znext = z\n               }\n         //\n         // vectorize\n         //\n         dxcur = xcur-xstart\n         dycur = ycur-ystart\n         dzcur = zcur-zstart\n         dcur = Math.sqrt(dxcur*dxcur+dycur*dycur+dzcur*dzcur)\n         nxcur = dxcur/dcur\n         nycur = dycur/dcur\n         nzcur = dzcur/dcur\n         dxnext = xnext-xcur\n         dynext = ynext-ycur\n         dznext = znext-zcur\n         dnext = Math.sqrt(dxnext*dxnext+dynext*dynext+dznext*dznext)\n         nxnext = dxnext/dnext\n         nynext = dynext/dnext\n         nznext = dznext/dnext\n         dot = nxcur*nxnext+nycur*nynext+nzcur*nznext\n         if (dot <= (1-error)) {\n            path[0].push([xcur,h-1-ycur,zcur])\n            xstart = xcur\n            ystart = ycur\n            zstart = zcur\n            }\n         xcur = xnext\n         ycur = ynext\n         zcur = znext\n         if (xcur == (w-1)) {\n            if (dx == 1) {\n               dx = 0\n               dy = -ystep\n               }\n            else {\n               dx = -1\n               dy = 0\n               }\n            }\n         else if (xcur == 0) {\n            if (dx == -1) {\n               dx = 0\n               dy = -ystep\n               }\n            else {\n               dx = 1\n               dy = 0\n               }\n            }\n         //\n         // update progress\n         //\n         self.postMessage({type:'progress',value:ycur})\n         }\n      //\n      // return\n      //\n      self.postMessage({type:'path',path:path})\n      self.close()\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n\n","top":"1532.2366382016226","left":"2241.0053466620584","inputs":{},"outputs":{}},"0.47383876715576023":{"definition":"//\n// distance transform \n//    assumes thresholded image, with zero intensity exterior\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2015,6\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the fab modules \n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'distance transform'\n//\n// initialization\n//\nvar init = function() {\n   }\n//\n// inputs\n//\nvar inputs = {\n   image:{type:'RGBA',\n      event:function(evt){\n         mod.input = evt.detail\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.width = mod.input.width\n         ctx.canvas.height = mod.input.height \n         ctx.putImageData(mod.input,0,0)\n         distance_transform()}}}\n//\n// outputs\n//\nvar outputs = {\n   distances:{type:'F32',\n      event:function(){\n         mod.distances.height = mod.input.height\n         mod.distances.width = mod.input.width\n         mods.output(mod,'distances',mod.distances)}}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen drawing canvas\n   //\n   var canvas = document.createElement('canvas')\n      canvas.width = mods.ui.canvas\n      canvas.height = mods.ui.canvas\n      canvas.style.backgroundColor = 'rgb(255,255,255)'\n      div.appendChild(canvas)\n      mod.canvas = canvas\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // view button\n   //\n   div.appendChild(document.createElement('br'))\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var canvas = document.createElement('canvas')\n            canvas.width = mod.img.width\n            canvas.height = mod.img.height\n            win.document.body.appendChild(canvas)\n         var ctx = canvas.getContext(\"2d\")\n            ctx.drawImage(mod.img,0,0)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// distance transform function\n//\nfunction distance_transform() {\n   var blob = new Blob(['('+worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      var h = mod.img.height\n      var w = mod.img.width\n      mod.distances = new Float32Array(evt.data.buffer)\n      var imgbuf = new Uint8ClampedArray(h*w*4)\n      var dmax = -Number.MAX_VALUE\n      for (var y = 0; y < h; ++y) {\n         for (var x = 0; x < w; ++x) {\n            if (mod.distances[(h-1-y)*w+x] > dmax)\n               dmax = mod.distances[(h-1-y)*w+x]\n            }\n         }\n      var i\n      for (var y = 0; y < h; ++y) {\n         for (var x = 0; x < w; ++x) {\n            i = 255*mod.distances[(h-1-y)*w+x]/dmax\n            imgbuf[(h-1-y)*w*4+x*4+0] = i\n            imgbuf[(h-1-y)*w*4+x*4+1] = i\n            imgbuf[(h-1-y)*w*4+x*4+2] = i\n            imgbuf[(h-1-y)*w*4+x*4+3] = 255\n            }\n         }\n      var imgdata = new ImageData(imgbuf,w,h)\n      var ctx = mod.img.getContext(\"2d\")\n      ctx.putImageData(imgdata,0,0)\n      if (w > h) {\n         var x0 = 0\n         var y0 = mod.canvas.height*.5*(1-h/w)\n         var wd = mod.canvas.width\n         var hd = mod.canvas.width*h/w\n         }\n      else {\n         var x0 = mod.canvas.width*.5*(1-w/h)\n         var y0 = 0\n         var wd = mod.canvas.height*w/h\n         var hd = mod.canvas.height\n         }\n      var ctx = mod.canvas.getContext(\"2d\")\n      ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n      ctx.drawImage(mod.img,x0,y0,wd,hd)\n      webworker.terminate()\n      outputs.distances.event()\n      })\n   var ctx = mod.canvas.getContext(\"2d\")\n   ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n   var ctx = mod.img.getContext(\"2d\")\n   ctx.putImageData(mod.input,0,0)\n   var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n   webworker.postMessage({\n      height:mod.input.height,width:mod.input.width,\n      buffer:img.data.buffer},\n      [img.data.buffer])\n   }\n//\n// distance transform worker\n//\nfunction worker() {\n   self.addEventListener('message',function(evt) {\n      var ny = evt.data.height\n      var nx = evt.data.width\n      var input = new Uint8ClampedArray(evt.data.buffer)\n      var output = new Float32Array(nx*ny)\n      function distance(g,x,y,i) {\n         return ((y-i)*(y-i)+g[i][x]*g[i][x])\n         }\n      function intersection(g,x,y0,y1) {\n         return ((g[y0][x]*g[y0][x]-g[y1][x]*g[y1][x]+y0*y0-y1*y1)/(2.0*(y0-y1)))\n         }\n      //\n      // allocate arrays\n      //\n      var g = []\n      for (var y = 0; y < ny; ++y)\n         g[y] = new Uint32Array(nx)\n      var h = []\n      for (var y = 0; y < ny; ++y)\n         h[y] = new Uint32Array(nx)\n      var distances = []\n      for (var y = 0; y < ny; ++y)\n         distances[y] = new Uint32Array(nx)\n      var starts = new Uint32Array(ny)\n      var minimums = new Uint32Array(ny)\n      var d\n      //\n      // column scan\n      //  \n      for (var y = 0; y < ny; ++y) {\n         //\n         // right pass\n         //\n         var closest = -nx\n         for (var x = 0; x < nx; ++x) {\n            if (input[(ny-1-y)*nx*4+x*4+0] != 0) {\n               g[y][x] = 0\n               closest = x\n               }\n            else\n               g[y][x] = (x-closest)\n            }\n         //\n         // left pass\n         //\n         closest = 2*nx\n         for (var x = (nx-1); x >= 0; --x) {\n            if (input[(ny-1-y)*nx*4+x*4+0] != 0)\n               closest = x\n            else {\n               d = (closest-x)\n               if (d < g[y][x])\n                  g[y][x] = d\n               }\n            }\n         }\n      //\n      // row scan\n      //\n      for (var x = 0; x < nx; ++x) {\n         var segment = 0\n         starts[0] = 0\n         minimums[0] = 0\n         //\n         // down \n         //\n         for (var y = 1; y < ny; ++y) {\n            while ((segment >= 0) &&\n               (distance(g,x,starts[segment],minimums[segment]) > distance(g,x,starts[segment],y)))\n               segment -= 1\n            if (segment < 0) {\n               segment = 0\n               minimums[0] = y\n               }\n            else {\n               newstart = 1+intersection(g,x,minimums[segment],y)\n               if (newstart < ny) {\n                  segment += 1\n                  minimums[segment] = y\n                  starts[segment] = newstart\n                  }\n               }\n            }\n         //\n         // up \n         //\n         for (var y = (ny-1); y >= 0; --y) {\n            d = Math.sqrt(distance(g,x,y,minimums[segment]))\n            output[(ny-1-y)*nx+x] = d\n            if (y == starts[segment])\n               segment -= 1\n            }\n         }\n      self.postMessage({buffer:output.buffer},[output.buffer])\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"-40.3476800709235","left":"3238.520596997833","inputs":{},"outputs":{}},"0.07944144280928633":{"definition":"//\n// edge detect\n//    green = interior, blue = exterior, red = boundary\n//    assumes input is thresholded\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2015,6\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the fab modules \n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'edge detect'\n//\n// initialization\n//\nvar init = function() {\n   }\n//\n// inputs\n//\nvar inputs = {\n   image:{type:'RGBA',\n      event:function(evt){\n         mod.input = evt.detail\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.width = mod.input.width\n         ctx.canvas.height = mod.input.height \n         ctx.putImageData(mod.input,0,0)\n         edge_detect()}}}\n//\n// outputs\n//\nvar outputs = {\n   image:{type:'RGBA',\n      event:function(){\n         var ctx = mod.img.getContext(\"2d\")\n         var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n         mods.output(mod,'image',img)}}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen drawing canvas\n   //\n   var canvas = document.createElement('canvas')\n      canvas.width = mods.ui.canvas\n      canvas.height = mods.ui.canvas\n      canvas.style.backgroundColor = 'rgb(255,255,255)'\n      div.appendChild(canvas)\n      mod.canvas = canvas\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // view button\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         win.document.body.appendChild(document.createTextNode('green:interior, blue:exterior, red:boundary'))\n         win.document.body.appendChild(document.createElement('br'))\n         var canvas = document.createElement('canvas')\n            canvas.width = mod.img.width\n            canvas.height = mod.img.height\n            win.document.body.appendChild(canvas)\n         var ctx = canvas.getContext(\"2d\")\n            ctx.drawImage(mod.img,0,0)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// edge detect\n//\nfunction edge_detect() {\n   var blob = new Blob(['('+worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      var h = mod.img.height\n      var w = mod.img.width\n      var buf = new Uint8ClampedArray(evt.data.buffer)\n      var imgdata = new ImageData(buf,w,h)\n      var ctx = mod.img.getContext(\"2d\")\n      ctx.putImageData(imgdata,0,0)\n      if (w > h) {\n         var x0 = 0\n         var y0 = mod.canvas.height*.5*(1-h/w)\n         var wd = mod.canvas.width\n         var hd = mod.canvas.width*h/w\n         }\n      else {\n         var x0 = mod.canvas.width*.5*(1-w/h)\n         var y0 = 0\n         var wd = mod.canvas.height*w/h\n         var hd = mod.canvas.height\n         }\n      var ctx = mod.canvas.getContext(\"2d\")\n      ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n      ctx.drawImage(mod.img,x0,y0,wd,hd)\n      webworker.terminate()\n      outputs.image.event()\n      })\n   var ctx = mod.canvas.getContext(\"2d\")\n   ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n   webworker.postMessage({worker:worker.toString(),\n      height:mod.input.height,width:mod.input.width,\n      buffer:mod.input.data.buffer},\n      [mod.input.data.buffer])\n   }\nfunction worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var input = new Uint8ClampedArray(evt.data.buffer)\n      var output = new Uint8ClampedArray(h*w*4)\n      var i00,i0m,i0p,im0,ip0,imm,imp,ipm,ipp,row,col\n      //\n      // find edges - interior\n      //\n      for (row = 1; row < (h-1); ++row) {\n         for (col = 1; col < (w-1); ++col) {\n            i00 = (input[(h-1-row)*w*4+col*4+0] \n                      +input[(h-1-row)*w*4+col*4+1] \n                      +input[(h-1-row)*w*4+col*4+2])\n            i0p = (input[(h-1-row)*w*4+(col+1)*4+0] \n                      +input[(h-1-row)*w*4+(col+1)*4+1] \n                      +input[(h-1-row)*w*4+(col+1)*4+2])\n            ip0 = (input[(h-2-row)*w*4+col*4+0] \n                      +input[(h-2-row)*w*4+col*4+1] \n                      +input[(h-2-row)*w*4+col*4+2])\n            ipp = (input[(h-2-row)*w*4+(col+1)*4+0] \n                      +input[(h-2-row)*w*4+(col+1)*4+1] \n                      +input[(h-2-row)*w*4+(col+1)*4+2])\n            i0m = (input[(h-1-row)*w*4+(col-1)*4+0] \n                      +input[(h-1-row)*w*4+(col-1)*4+1] \n                      +input[(h-1-row)*w*4+(col-1)*4+2])\n            im0 = (input[(h-row)*w*4+col*4+0] \n                      +input[(h-row)*w*4+col*4+1] \n                      +input[(h-row)*w*4+col*4+2])\n            imm = (input[(h-row)*w*4+(col-1)*4+0] \n                      +input[(h-row)*w*4+(col-1)*4+1] \n                      +input[(h-row)*w*4+(col-1)*4+2])\n            imp = (input[(h-row)*w*4+(col+1)*4+0] \n                      +input[(h-row)*w*4+(col+1)*4+1] \n                      +input[(h-row)*w*4+(col+1)*4+2])\n            ipm = (input[(h-2-row)*w*4+(col-1)*4+0] \n                      +input[(h-2-row)*w*4+(col-1)*4+1] \n                      +input[(h-2-row)*w*4+(col-1)*4+2])\n            if ((i00 != i0p) || (i00 != ip0) || (i00 != ipp) \n               || (i00 != i0m) || (i00 != im0) || (i00 != imm)\n               || (i00 != imp) || (i00 != ipm)) {\n               output[(h-1-row)*w*4+col*4+0] = 255\n               output[(h-1-row)*w*4+col*4+1] = 0\n               output[(h-1-row)*w*4+col*4+2] = 0\n               output[(h-1-row)*w*4+col*4+3] = 255\n               }\n            else if (i00 == 0) {\n               output[(h-1-row)*w*4+col*4+0] = 0\n               output[(h-1-row)*w*4+col*4+1] = 0\n               output[(h-1-row)*w*4+col*4+2] = 255\n               output[(h-1-row)*w*4+col*4+3] = 255\n               }\n            else {\n               output[(h-1-row)*w*4+col*4+0] = 0\n               output[(h-1-row)*w*4+col*4+1] = 255\n               output[(h-1-row)*w*4+col*4+2] = 0\n               output[(h-1-row)*w*4+col*4+3] = 255\n               }\n            }\n         }\n      //\n      // left and right edges\n      //\n      for (row = 1; row < (h-1); ++row) {\n         col = w-1\n         i00 = (input[(h-1-row)*w*4+col*4+0] \n                   +input[(h-1-row)*w*4+col*4+1] \n                   +input[(h-1-row)*w*4+col*4+2])\n         i0m = (input[(h-1-row)*w*4+(col-1)*4+0] \n                   +input[(h-1-row)*w*4+(col-1)*4+1] \n                   +input[(h-1-row)*w*4+(col-1)*4+2])\n         imm = (input[(h-row)*w*4+(col-1)*4+0] \n                   +input[(h-row)*w*4+(col-1)*4+1] \n                   +input[(h-row)*w*4+(col-1)*4+2])\n         ipm = (input[(h-2-row)*w*4+(col-1)*4+0] \n                   +input[(h-2-row)*w*4+(col-1)*4+1] \n                   +input[(h-2-row)*w*4+(col-1)*4+2])\n         im0 = (input[(h-row)*w*4+col*4+0] \n                   +input[(h-row)*w*4+col*4+1] \n                   +input[(h-row)*w*4+col*4+2])\n         ip0 = (input[(h-2-row)*w*4+col*4+0] \n                   +input[(h-2-row)*w*4+col*4+1] \n                   +input[(h-2-row)*w*4+col*4+2])\n        if ((i00 != i0m) || (i00 != ip0) || (i00 != ipm) \n           || (i00 != im0) || (i00 != imm)) {\n           output[(h-1-row)*w*4+col*4+0] = 255\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else if (i00 == 0) {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 255\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 255\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n         col = 0\n         i00 = (input[(h-1-row)*w*4+col*4+0] \n                   +input[(h-1-row)*w*4+col*4+1] \n                   +input[(h-1-row)*w*4+col*4+2])\n         i0p = (input[(h-1-row)*w*4+(col+1)*4+0] \n                   +input[(h-1-row)*w*4+(col+1)*4+1] \n                   +input[(h-1-row)*w*4+(col+1)*4+2])\n         imp = (input[(h-row)*w*4+(col+1)*4+0] \n                   +input[(h-row)*w*4+(col+1)*4+1] \n                   +input[(h-row)*w*4+(col+1)*4+2])\n         ipp = (input[(h-2-row)*w*4+(col+1)*4+0] \n                   +input[(h-2-row)*w*4+(col+1)*4+1] \n                   +input[(h-2-row)*w*4+(col+1)*4+2])\n         im0 = (input[(h-row)*w*4+col*4+0] \n                   +input[(h-row)*w*4+col*4+1] \n                   +input[(h-row)*w*4+col*4+2])\n         ip0 = (input[(h-2-row)*w*4+col*4+0] \n                   +input[(h-2-row)*w*4+col*4+1] \n                   +input[(h-2-row)*w*4+col*4+2])\n        if ((i00 != i0p) || (i00 != ip0) || (i00 != ipp) \n           || (i00 != im0) || (i00 != imp)) {\n           output[(h-1-row)*w*4+col*4+0] = 255\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else if (i00 == 0) {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 255\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 255\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n         }\n      //\n      // top and bottom edges\n      //\n      for (col = 1; col < (w-1); ++col) {\n         row = h-1\n         i00 = (input[(h-1-row)*w*4+col*4+0] \n                   +input[(h-1-row)*w*4+col*4+1] \n                   +input[(h-1-row)*w*4+col*4+2])\n         i0m = (input[(h-1-row)*w*4+(col-1)*4+0] \n                   +input[(h-1-row)*w*4+(col-1)*4+1] \n                   +input[(h-1-row)*w*4+(col-1)*4+2])\n         i0p = (input[(h-1-row)*w*4+(col+1)*4+0] \n                   +input[(h-1-row)*w*4+(col+1)*4+1] \n                   +input[(h-1-row)*w*4+(col+1)*4+2])\n         imm = (input[(h-row)*w*4+(col-1)*4+0] \n                   +input[(h-row)*w*4+(col-1)*4+1] \n                   +input[(h-row)*w*4+(col-1)*4+2])\n         im0 = (input[(h-row)*w*4+col*4+0] \n                   +input[(h-row)*w*4+col*4+1] \n                   +input[(h-row)*w*4+col*4+2])\n         imp = (input[(h-row)*w*4+(col+1)*4+0] \n                   +input[(h-row)*w*4+(col+1)*4+1] \n                   +input[(h-row)*w*4+(col+1)*4+2])\n        if ((i00 != i0m) || (i00 != i0p) || (i00 != imm) \n           || (i00 != im0) || (i00 != imp)) {\n           output[(h-1-row)*w*4+col*4+0] = 255\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else if (i00 == 0) {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 255\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 255\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n         row = 0\n         i00 = (input[(h-1-row)*w*4+col*4+0] \n                   +input[(h-1-row)*w*4+col*4+1] \n                   +input[(h-1-row)*w*4+col*4+2])\n         i0m = (input[(h-1-row)*w*4+(col-1)*4+0] \n                   +input[(h-1-row)*w*4+(col-1)*4+1] \n                   +input[(h-1-row)*w*4+(col-1)*4+2])\n         i0p = (input[(h-1-row)*w*4+(col+1)*4+0] \n                   +input[(h-1-row)*w*4+(col+1)*4+1] \n                   +input[(h-1-row)*w*4+(col+1)*4+2])\n         ipm = (input[(h-2-row)*w*4+(col-1)*4+0] \n                   +input[(h-2-row)*w*4+(col-1)*4+1] \n                   +input[(h-2-row)*w*4+(col-1)*4+2])\n         ip0 = (input[(h-2-row)*w*4+col*4+0] \n                   +input[(h-2-row)*w*4+col*4+1] \n                   +input[(h-2-row)*w*4+col*4+2])\n         ipp = (input[(h-2-row)*w*4+(col+1)*4+0] \n                   +input[(h-2-row)*w*4+(col+1)*4+1] \n                   +input[(h-2-row)*w*4+(col+1)*4+2])\n        if ((i00 != i0m) || (i00 != i0p) || (i00 != ipm) \n           || (i00 != ip0) || (i00 != ipp)) {\n           output[(h-1-row)*w*4+col*4+0] = 255\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else if (i00 == 0) {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 0\n           output[(h-1-row)*w*4+col*4+2] = 255\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n        else {\n           output[(h-1-row)*w*4+col*4+0] = 0\n           output[(h-1-row)*w*4+col*4+1] = 255\n           output[(h-1-row)*w*4+col*4+2] = 0\n           output[(h-1-row)*w*4+col*4+3] = 255\n           }\n         }\n      //\n      // corners\n      //\n      row = 0\n      col = 0\n      i00 = (input[(h-1-row)*w*4+col*4+0] \n                +input[(h-1-row)*w*4+col*4+1] \n                +input[(h-1-row)*w*4+col*4+2])\n      i0p = (input[(h-1-row)*w*4+(col+1)*4+0] \n                +input[(h-1-row)*w*4+(col+1)*4+1] \n                +input[(h-1-row)*w*4+(col+1)*4+2])\n      ip0 = (input[(h-2-row)*w*4+col*4+0] \n                +input[(h-2-row)*w*4+col*4+1] \n                +input[(h-2-row)*w*4+col*4+2])\n      ipp = (input[(h-2-row)*w*4+(col+1)*4+0] \n                +input[(h-2-row)*w*4+(col+1)*4+1] \n                +input[(h-2-row)*w*4+(col+1)*4+2])\n      if ((i00 != i0p) || (i00 != ip0) || (i00 != ipp)) {\n         output[(h-1-row)*w*4+col*4+0] = 255\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else if (i00 == 0) {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 255\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 255\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      row = 0\n      col = w-1\n      i00 = (input[(h-1-row)*w*4+col*4+0] \n                +input[(h-1-row)*w*4+col*4+1] \n                +input[(h-1-row)*w*4+col*4+2])\n      i0m = (input[(h-1-row)*w*4+(col-1)*4+0] \n                +input[(h-1-row)*w*4+(col-1)*4+1] \n                +input[(h-1-row)*w*4+(col-1)*4+2])\n      ip0 = (input[(h-2-row)*w*4+col*4+0] \n                +input[(h-2-row)*w*4+col*4+1] \n                +input[(h-2-row)*w*4+col*4+2])\n      ipm = (input[(h-2-row)*w*4+(col-1)*4+0] \n                +input[(h-2-row)*w*4+(col-1)*4+1] \n                +input[(h-2-row)*w*4+(col-1)*4+2])\n      if ((i00 != i0m) || (i00 != ip0) || (i00 != ipm)) {\n         output[(h-1-row)*w*4+col*4+0] = 255\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else if (i00 == 0) {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 255\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 255\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      row = h-1\n      col = 0\n      i00 = (input[(h-1-row)*w*4+col*4+0] \n                +input[(h-1-row)*w*4+col*4+1] \n                +input[(h-1-row)*w*4+col*4+2])\n      i0p = (input[(h-1-row)*w*4+(col+1)*4+0] \n                +input[(h-1-row)*w*4+(col+1)*4+1] \n                +input[(h-1-row)*w*4+(col+1)*4+2])\n      im0 = (input[(h-row)*w*4+col*4+0] \n                +input[(h-row)*w*4+col*4+1] \n                +input[(h-row)*w*4+col*4+2])\n      imp = (input[(h-row)*w*4+(col+1)*4+0] \n                +input[(h-row)*w*4+(col+1)*4+1] \n                +input[(h-row)*w*4+(col+1)*4+2])\n      if ((i00 != i0p) || (i00 != im0) || (i00 != imp)) {\n         output[(h-1-row)*w*4+col*4+0] = 255\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else if (i00 == 0) {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 255\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 255\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      row = h-1\n      col = w-1\n      i00 = (input[(h-1-row)*w*4+col*4+0] \n                +input[(h-1-row)*w*4+col*4+1] \n                +input[(h-1-row)*w*4+col*4+2])\n      i0m = (input[(h-1-row)*w*4+(col-1)*4+0] \n                +input[(h-1-row)*w*4+(col-1)*4+1] \n                +input[(h-1-row)*w*4+(col-1)*4+2])\n      im0 = (input[(h-row)*w*4+col*4+0] \n                +input[(h-row)*w*4+col*4+1] \n                +input[(h-row)*w*4+col*4+2])\n      imm = (input[(h-row)*w*4+(col-1)*4+0] \n                +input[(h-row)*w*4+(col-1)*4+1] \n                +input[(h-row)*w*4+(col-1)*4+2])\n      if ((i00 != i0m) || (i00 != im0) || (i00 != imm)) {\n         output[(h-1-row)*w*4+col*4+0] = 255\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else if (i00 == 0) {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 0\n         output[(h-1-row)*w*4+col*4+2] = 255\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      else {\n         output[(h-1-row)*w*4+col*4+0] = 0\n         output[(h-1-row)*w*4+col*4+1] = 255\n         output[(h-1-row)*w*4+col*4+2] = 0\n         output[(h-1-row)*w*4+col*4+3] = 255\n         }\n      self.postMessage({buffer:output.buffer},[output.buffer])\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"601.8788934664619","left":"3810.9261466603243","inputs":{},"outputs":{}},"0.8903773266711255":{"definition":"//\n// orient edges\n//    input is green:interior, blue:exterior, red:boundary\n//    output is red 128:north,64:south, green 128:east,64:west, blue 128:start,64:stop\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2016\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the fab modules \n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'orient edges'\n//\n// initialization\n//\nvar init = function() {\n   }\n//\n// inputs\n//\nvar inputs = {\n   image:{type:'RGBA',\n      event:function(evt){\n         mod.input = evt.detail\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.width = mod.input.width\n         ctx.canvas.height = mod.input.height \n         ctx.putImageData(mod.input,0,0)\n         var ctx = mod.display.getContext(\"2d\")\n         ctx.canvas.width = mod.input.width\n         ctx.canvas.height = mod.input.height \n         orient_edges()\n         }}}\n//\n// outputs\n//\nvar outputs = {\n   image:{type:'RGBA',\n      event:function(){\n         var ctx = mod.img.getContext(\"2d\")\n         var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n         mods.output(mod,'image',img)}}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen drawing canvas\n   //\n   var canvas = document.createElement('canvas')\n      canvas.width = mods.ui.canvas\n      canvas.height = mods.ui.canvas\n      canvas.style.backgroundColor = 'rgb(255,255,255)'\n      div.appendChild(canvas)\n      mod.canvas = canvas\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // off-screen display canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.display = canvas\n   //\n   // view button\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         win.document.body.appendChild(document.createTextNode('red:north, dark red:south'))\n         win.document.body.appendChild(document.createElement('br'))\n         win.document.body.appendChild(document.createTextNode('green:east, dark green:west'))\n         win.document.body.appendChild(document.createElement('br'))\n         win.document.body.appendChild(document.createTextNode('blue:start, dark blue:stop'))\n         win.document.body.appendChild(document.createElement('br'))\n         var canvas = document.createElement('canvas')\n            canvas.width = mod.img.width\n            canvas.height = mod.img.height\n            win.document.body.appendChild(canvas)\n         var ctx = canvas.getContext(\"2d\")\n            ctx.drawImage(mod.display,0,0)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// orient edges\n//\nfunction orient_edges() {\n   var blob = new Blob(['('+worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      var h = mod.img.height\n      var w = mod.img.width\n      var buf = new Uint8ClampedArray(evt.data.buffer)\n      var imgdata = new ImageData(buf,w,h)\n      var ctx = mod.img.getContext(\"2d\")\n      ctx.putImageData(imgdata,0,0)\n      var disp = new Uint8ClampedArray(evt.data.display)\n      var dispdata = new ImageData(disp,w,h)\n      var ctx = mod.display.getContext(\"2d\")\n      ctx.putImageData(dispdata,0,0)\n      if (w > h) {\n         var x0 = 0\n         var y0 = mod.canvas.height*.5*(1-h/w)\n         var wd = mod.canvas.width\n         var hd = mod.canvas.width*h/w\n         }\n      else {\n         var x0 = mod.canvas.width*.5*(1-w/h)\n         var y0 = 0\n         var wd = mod.canvas.height*w/h\n         var hd = mod.canvas.height\n         }\n      var w = mod.canvas.width\n      var h = mod.canvas.height\n      var ctx = mod.canvas.getContext(\"2d\")\n      ctx.clearRect(0,0,w,h)\n      ctx.drawImage(mod.display,x0,y0,wd,hd)\n      webworker.terminate()\n      outputs.image.event()\n      })\n   var ctx = mod.canvas.getContext(\"2d\")\n   ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n   webworker.postMessage({\n      height:mod.input.height,width:mod.input.width,\n      buffer:mod.input.data.buffer},\n      [mod.input.data.buffer])\n   }\nfunction worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var input = new Uint8ClampedArray(evt.data.buffer)\n      var output = new Uint8ClampedArray(h*w*4)\n      var row,col\n      var boundary = 0\n      var interior = 1\n      var exterior = 2\n      var alpha = 3\n      var northsouth = 0\n      var north = 128\n      var south = 64\n      var eastwest = 1\n      var east = 128\n      var west = 64\n      var startstop = 2\n      var start = 128\n      var stop = 64\n      //\n      // orient body states\n      //\n      for (row = 1; row < (h-1); ++row) {\n         for (col = 1; col < (w-1); ++col) {\n            output[(h-1-row)*w*4+col*4+northsouth] = 0\n            output[(h-1-row)*w*4+col*4+eastwest] = 0\n            output[(h-1-row)*w*4+col*4+startstop] = 0\n            output[(h-1-row)*w*4+col*4+alpha] = 255\n            if (input[(h-1-(row))*w*4+(col)*4+boundary] != 0) {\n               if ((input[(h-1-(row+1))*w*4+(col)*4+boundary] != 0)\n                  && ((input[(h-1-(row))*w*4+(col+1)*4+interior] != 0)\n                  || (input[(h-1-(row+1))*w*4+(col+1)*4+interior] != 0)))\n                  output[(h-1-row)*w*4+col*4+northsouth] |= north\n               if ((input[(h-1-(row-1))*w*4+(col)*4+boundary] != 0)\n                  && ((input[(h-1-(row))*w*4+(col-1)*4+interior] != 0)\n                  || (input[(h-1-(row-1))*w*4+(col-1)*4+interior] != 0)))\n                  output[(h-1-row)*w*4+col*4+northsouth] |= south\n               if ((input[(h-1-(row))*w*4+(col+1)*4+boundary] != 0)\n                  && ((input[(h-1-(row-1))*w*4+(col)*4+interior] != 0)\n                  || (input[(h-1-(row-1))*w*4+(col+1)*4+interior] != 0)))\n                  output[(h-1-row)*w*4+col*4+eastwest] |= east\n               if ((input[(h-1-(row))*w*4+(col-1)*4+boundary] != 0)\n                  && ((input[(h-1-(row+1))*w*4+(col)*4+interior] != 0)\n                  || (input[(h-1-(row+1))*w*4+(col-1)*4+interior] != 0)))\n                  output[(h-1-row)*w*4+col*4+eastwest] |= west\n               }\n            }\n         }\n      //\n      // orient edge states\n      //\n      for (col = 1; col < (w-1); ++col) {\n         row = 0\n         output[(h-1-row)*w*4+col*4+northsouth] = 0\n         output[(h-1-row)*w*4+col*4+eastwest] = 0\n         output[(h-1-row)*w*4+col*4+startstop] = 0\n         output[(h-1-row)*w*4+col*4+alpha] = 255\n         if (input[(h-1-(row))*w*4+(col)*4+boundary] != 0) {\n            if ((input[(h-1-(row+1))*w*4+(col)*4+boundary] != 0)\n               && (input[(h-1-(row))*w*4+(col+1)*4+interior] != 0)) {\n               output[(h-1-row)*w*4+col*4+northsouth] |= north\n               output[(h-1-row)*w*4+col*4+startstop] |= start\n               }\n            if (input[(h-1-(row))*w*4+(col-1)*4+interior] != 0)\n               output[(h-1-row)*w*4+col*4+startstop] |= stop\n            }\n         row = h-1\n         output[(h-1-row)*w*4+col*4+northsouth] = 0\n         output[(h-1-row)*w*4+col*4+eastwest] = 0\n         output[(h-1-row)*w*4+col*4+startstop] = 0\n         output[(h-1-row)*w*4+col*4+alpha] = 255\n         if (input[(h-1-(row))*w*4+(col)*4+boundary] != 0) {\n            if (input[(h-1-(row))*w*4+(col+1)*4+interior] != 0)\n               output[(h-1-row)*w*4+col*4+startstop] |= stop\n            if ((input[(h-1-(row-1))*w*4+(col)*4+boundary] != 0)\n               && (input[(h-1-(row))*w*4+(col-1)*4+interior] != 0)) {\n               output[(h-1-row)*w*4+col*4+northsouth] |= south\n               output[(h-1-row)*w*4+col*4+startstop] |= start\n               }\n            }\n         }\n      for (row = 1; row < (h-1); ++row) {\n         col = 0\n         output[(h-1-row)*w*4+col*4+northsouth] = 0\n         output[(h-1-row)*w*4+col*4+eastwest] = 0\n         output[(h-1-row)*w*4+col*4+startstop] = 0\n         output[(h-1-row)*w*4+col*4+alpha] = 255\n         if (input[(h-1-(row))*w*4+(col)*4+boundary] != 0) {\n            if ((input[(h-1-(row))*w*4+(col+1)*4+boundary] != 0)\n               && (input[(h-1-(row-1))*w*4+(col)*4+interior] != 0)) {\n               output[(h-1-row)*w*4+col*4+eastwest] |= east\n               output[(h-1-row)*w*4+col*4+startstop] |= start\n               }\n            if (input[(h-1-(row+1))*w*4+(col)*4+interior] != 0)\n               output[(h-1-row)*w*4+col*4+startstop] |= stop\n            }\n         col = w-1\n         output[(h-1-row)*w*4+col*4+northsouth] = 0\n         output[(h-1-row)*w*4+col*4+eastwest] = 0\n         output[(h-1-row)*w*4+col*4+startstop] = 0\n         output[(h-1-row)*w*4+col*4+alpha] = 255\n         if (input[(h-1-(row))*w*4+(col)*4+boundary] != 0) {\n            if (input[(h-1-(row-1))*w*4+(col)*4+interior] != 0)\n               output[(h-1-row)*w*4+col*4+startstop] |= stop\n            if ((input[(h-1-(row))*w*4+(col-1)*4+boundary] != 0)\n               && (input[(h-1-(row+1))*w*4+(col)*4+interior] != 0)) {\n               output[(h-1-row)*w*4+col*4+eastwest] |= west\n               output[(h-1-row)*w*4+col*4+startstop] |= start\n               }\n            }\n         }\n      //\n      // orient corner states (todo)\n      //\n      row = 0\n      col = 0\n      output[(h-1-row)*w*4+col*4+northsouth] = 0\n      output[(h-1-row)*w*4+col*4+eastwest] = 0\n      output[(h-1-row)*w*4+col*4+startstop] = 0\n      output[(h-1-row)*w*4+col*4+alpha] = 255\n      row = h-1\n      col = 0\n      output[(h-1-row)*w*4+col*4+northsouth] = 0\n      output[(h-1-row)*w*4+col*4+eastwest] = 0\n      output[(h-1-row)*w*4+col*4+startstop] = 0\n      output[(h-1-row)*w*4+col*4+alpha] = 255\n      row = 0\n      col = w-1\n      output[(h-1-row)*w*4+col*4+northsouth] = 0\n      output[(h-1-row)*w*4+col*4+eastwest] = 0\n      output[(h-1-row)*w*4+col*4+startstop] = 0\n      output[(h-1-row)*w*4+col*4+alpha] = 255\n      row = h-1\n      col = w-1\n      output[(h-1-row)*w*4+col*4+northsouth] = 0\n      output[(h-1-row)*w*4+col*4+eastwest] = 0\n      output[(h-1-row)*w*4+col*4+startstop] = 0\n      output[(h-1-row)*w*4+col*4+alpha] = 255\n      //\n      // invert background for display\n      //\n      var display = new Uint8ClampedArray(h*w*4)\n      var r,g,b,i\n      for (row = 0; row < h; ++row) {\n         for (col = 0; col < w; ++col) {\n            r = output[(h-1-row)*w*4+col*4+0]\n            g = output[(h-1-row)*w*4+col*4+1]\n            b = output[(h-1-row)*w*4+col*4+2]\n            i = r+g+b\n            if (i != 0) {            \n               display[(h-1-row)*w*4+col*4+0] = output[(h-1-row)*w*4+col*4+0]\n               display[(h-1-row)*w*4+col*4+1] = output[(h-1-row)*w*4+col*4+1]\n               display[(h-1-row)*w*4+col*4+2] = output[(h-1-row)*w*4+col*4+2]\n               display[(h-1-row)*w*4+col*4+3] = output[(h-1-row)*w*4+col*4+3]\n               }\n            else {\n               display[(h-1-row)*w*4+col*4+0] = 255\n               display[(h-1-row)*w*4+col*4+1] = 255\n               display[(h-1-row)*w*4+col*4+2] = 255\n               display[(h-1-row)*w*4+col*4+3] = 255\n               }\n            }\n         }\n      //\n      // return output\n      //\n      self.postMessage({buffer:output.buffer,display:display.buffer},[output.buffer,display.buffer])\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"493.3741962744334","left":"3290.2869365436013","inputs":{},"outputs":{}},"0.6488303557466412":{"definition":"//\n// image threshold\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2015,6\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the fab modules \n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'image threshold'\n//\n// initialization\n//\nvar init = function() {\n   mod.threshold.value = '0.5'\n   }\n//\n// inputs\n//\nvar inputs = {\n   image:{type:'RGBA',\n      event:function(evt){\n         mod.input = evt.detail\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.width = mod.input.width\n         ctx.canvas.height = mod.input.height \n         ctx.putImageData(mod.input,0,0)\n         threshold_image()}}}\n//\n// outputs\n//\nvar outputs = {\n   image:{type:'RGBA',\n      event:function(){\n         var ctx = mod.img.getContext(\"2d\")\n         var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n         mods.output(mod,'image',img)}}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen drawing canvas\n   //\n   var canvas = document.createElement('canvas')\n      canvas.width = mods.ui.canvas\n      canvas.height = mods.ui.canvas\n      canvas.style.backgroundColor = 'rgb(255,255,255)'\n      div.appendChild(canvas)\n      mod.canvas = canvas\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // threshold value\n   //\n   div.appendChild(document.createTextNode('threshold (0-1): '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         threshold_image()\n         })\n      div.appendChild(input)\n      mod.threshold = input\n   div.appendChild(document.createElement('br'))\n   //\n   // view button\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var canvas = document.createElement('canvas')\n            canvas.width = mod.img.width\n            canvas.height = mod.img.height\n            win.document.body.appendChild(canvas)\n         var ctx = canvas.getContext(\"2d\")\n            ctx.drawImage(mod.img,0,0)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// threshold image\n//\nfunction threshold_image() {\n   var blob = new Blob(['('+worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      var h = mod.img.height\n      var w = mod.img.width\n      var buf = new Uint8ClampedArray(evt.data.buffer)\n      var imgdata = new ImageData(buf,w,h)\n      var ctx = mod.img.getContext(\"2d\")\n      ctx.putImageData(imgdata,0,0)\n      if (w > h) {\n         var x0 = 0\n         var y0 = mod.canvas.height*.5*(1-h/w)\n         var wd = mod.canvas.width\n         var hd = mod.canvas.width*h/w\n         }\n      else {\n         var x0 = mod.canvas.width*.5*(1-w/h)\n         var y0 = 0\n         var wd = mod.canvas.height*w/h\n         var hd = mod.canvas.height\n         }\n      var ctx = mod.canvas.getContext(\"2d\")\n      ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n      ctx.drawImage(mod.img,x0,y0,wd,hd)\n      webworker.terminate()\n      outputs.image.event()\n      })\n   var ctx = mod.canvas.getContext(\"2d\")\n   ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n   var t = parseFloat(mod.threshold.value)\n   var ctx = mod.img.getContext(\"2d\")\n   ctx.putImageData(mod.input,0,0)\n   var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n   webworker.postMessage({\n      height:mod.input.height,width:mod.input.width,threshold:t,\n      buffer:img.data.buffer},\n      [img.data.buffer])\n   }\nfunction worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var t = evt.data.threshold\n      var buf = new Uint8ClampedArray(evt.data.buffer)\n      var r,g,b,a,i\n      for (var row = 0; row < h; ++row) {\n         for (var col = 0; col < w; ++col) {\n            r = buf[(h-1-row)*w*4+col*4+0] \n            g = buf[(h-1-row)*w*4+col*4+1] \n            b = buf[(h-1-row)*w*4+col*4+2] \n            a = buf[(h-1-row)*w*4+col*4+3] \n            i = (r+g+b)/(3*255)\n            if (a == 0)\n               val = 255\n            else if (i > t)\n               var val = 255\n            else\n               var val = 0\n            buf[(h-1-row)*w*4+col*4+0] = val\n            buf[(h-1-row)*w*4+col*4+1] = val\n            buf[(h-1-row)*w*4+col*4+2] = val\n            buf[(h-1-row)*w*4+col*4+3] = 255\n            }\n         }\n      self.postMessage({buffer:buf.buffer},[buf.buffer])\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"-150.4109152875248","left":"2750.7304594664856","inputs":{},"outputs":{}},"0.749132408760488":{"definition":"//\n// vectorize\n//    input is red 128:north,64:south, green 128:east,64:west, blue 128:start,64:stop\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2016\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the fab modules \n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'vectorize'\n//\n// initialization\n//\nvar init = function() {\n   mod.error.value = '1'\n   }\n//\n// inputs\n//\nvar inputs = {\n   image:{type:'RGBA',\n      event:function(evt){\n         mod.input = evt.detail\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.width = mod.input.width\n         ctx.canvas.height = mod.input.height \n         ctx.putImageData(mod.input,0,0)\n         vectorize()\n         }}}\n//\n// outputs\n//\nvar outputs = {\n   path:{type:'array',\n      event:function(){\n         mods.output(mod,'path',mod.path)\n         }}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen SVG\n   //\n   var svgNS = \"http://www.w3.org/2000/svg\"\n   var svg = document.createElementNS(svgNS,\"svg\")\n   svg.setAttribute('id',mod.div.id+'svg')\n   svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\",\n      \"xmlns:xlink\",\"http://www.w3.org/1999/xlink\")\n   svg.setAttribute('width',mods.ui.canvas)\n   svg.setAttribute('height',mods.ui.canvas)\n   svg.style.backgroundColor = 'rgb(255,255,255)'\n   var g = document.createElementNS(svgNS,'g')\n   g.setAttribute('id',mod.div.id+'g')\n   svg.appendChild(g)\n   div.appendChild(svg)\n   div.appendChild(document.createElement('br'))   \n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // error value\n   //\n   div.appendChild(document.createTextNode('vector fit (pixels): '))\n   //div.appendChild(document.createElement('br'))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         vectorize()\n         })\n      div.appendChild(input)\n      mod.error = input\n   div.appendChild(document.createElement('br'))\n   //\n   // sort\n   //\n   div.appendChild(document.createTextNode('sort distance: '))\n   var input = document.createElement('input')\n      input.type = 'checkbox'\n      input.id = mod.div.id+'sort'\n      input.checked = true\n      div.appendChild(input)\n      mod.sort = input\n   div.appendChild(document.createElement('br'))\n   //\n   // view button\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var svg = document.getElementById(mod.div.id+'svg')\n         var clone = svg.cloneNode(true)\n         clone.setAttribute('width',mod.img.width)\n         clone.setAttribute('height',mod.img.height)\n         win.document.body.appendChild(clone)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// vectorize\n//\nfunction vectorize() {\n   //\n   // draw path\n   //\n   function draw_path(path) {\n      window.URL.revokeObjectURL(url)\n      var svg = document.getElementById(mod.div.id+'svg')\n      svg.setAttribute('viewBox',\"0 0 \"+(mod.img.width-1)+\" \"+(mod.img.height-1))\n      var g = document.getElementById(mod.div.id+'g')\n      svg.removeChild(g)\n      var g = document.createElementNS('http://www.w3.org/2000/svg','g')\n      g.setAttribute('id',mod.div.id+'g')\n      var h = mod.img.height\n      var w = mod.img.width\n      var xend = null\n      var yend = null\n      //\n      // loop over segments\n      //\n      for (var segment in path) {\n         if (path[segment].length > 1) {\n            if (xend != null) {\n               //\n               // draw connection from previous segment\n               //\n               var line = document.createElementNS('http://www.w3.org/2000/svg','line')\n               line.setAttribute('stroke','red')\n               line.setAttribute('stroke-width',1)\n               line.setAttribute('stroke-linecap','round')\n               var x1 = xend\n               var y1 = yend\n               var x2 = path[segment][0][0]\n               var y2 = h-path[segment][0][1]-1\n               line.setAttribute('x1',x1)\n               line.setAttribute('y1',y1)\n               line.setAttribute('x2',x2)\n               line.setAttribute('y2',y2)\n               var dx = x2-x1\n               var dy = y2-y1\n               var d = Math.sqrt(dx*dx+dy*dy)\n               if (d > 0) {\n                  nx = 6*dx/d\n                  ny = 6*dy/d\n                  var tx = 3*dy/d\n                  var ty = -3*dx/d\n                  g.appendChild(line)\n                  triangle = document.createElementNS('http://www.w3.org/2000/svg','polygon')\n                  triangle.setAttribute('points',x2+','+y2+' '+(x2-nx+tx)+','+(y2-ny+ty)\n                     +' '+(x2-nx-tx)+','+(y2-ny-ty))\n                  triangle.setAttribute('fill','red')\n                  g.appendChild(triangle)\n                  }\n               }\n            //\n            // loop over points\n            //\n            for (var point = 1; point < path[segment].length; ++point) {\n               var line = document.createElementNS('http://www.w3.org/2000/svg','line')\n               line.setAttribute('stroke','black')\n               line.setAttribute('stroke-width',1)\n               line.setAttribute('stroke-linecap','round')\n               var x1 = path[segment][point-1][0]\n               var y1 = h-path[segment][point-1][1]-1\n               var x2 = path[segment][point][0]\n               var y2 = h-path[segment][point][1]-1\n               xend = x2\n               yend = y2\n               line.setAttribute('x1',x1)\n               line.setAttribute('y1',y1)\n               line.setAttribute('x2',x2)\n               line.setAttribute('y2',y2)\n               var dx = x2-x1\n               var dy = y2-y1\n               var d = Math.sqrt(dx*dx+dy*dy)\n               if (d > 0) {\n                  nx = 6*dx/d\n                  ny = 6*dy/d\n                  var tx = 3*dy/d\n                  var ty = -3*dx/d\n                  g.appendChild(line)\n                  triangle = document.createElementNS('http://www.w3.org/2000/svg','polygon')\n                  triangle.setAttribute('points',x2+','+y2+' '+(x2-nx+tx)+','+(y2-ny+ty)\n                     +' '+(x2-nx-tx)+','+(y2-ny-ty))\n                  triangle.setAttribute('fill','black')\n                  g.appendChild(triangle)\n                  }\n               }\n            }\n         }\n      svg.appendChild(g)\n      }\n   //\n   // set up worker\n   //\n   var blob = new Blob(['('+worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      webworker.terminate()\n      mod.path = evt.data.path\n      draw_path(mod.path)\n      outputs.path.event()\n      })\n   //\n   // call worker\n   //\n   webworker.postMessage({\n      height:mod.input.height,width:mod.input.width,sort:mod.sort.checked,\n      error:parseFloat(mod.error.value),\n      buffer:mod.input.data.buffer})\n   }\n//\n// vectorize worker\n//\nfunction worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var sort = evt.data.sort\n      var input = new Uint8ClampedArray(evt.data.buffer)\n      var northsouth = 0\n      var north = 128\n      var south = 64\n      var eastwest = 1\n      var east = 128\n      var west = 64\n      var startstop = 2\n      var start = 128\n      var stop = 64\n      var path = []\n      //\n      // edge follower\n      //\n      function follow_edges(row,col) {\n         if ((input[(h-1-row)*w*4+col*4+northsouth] != 0)\n            || (input[(h-1-row)*w*4+col*4+eastwest] != 0)) {\n            path[path.length] = [[col,row]]\n            while (1) {\n               if (input[(h-1-row)*w*4+col*4+northsouth] & north) {\n                  input[(h-1-row)*w*4+col*4+northsouth] =\n                     input[(h-1-row)*w*4+col*4+northsouth] & ~north\n                  row += 1\n                  path[path.length-1][path[path.length-1].length] = [col,row]\n                  }\n               else if (input[(h-1-row)*w*4+col*4+northsouth] & south) {\n                  input[(h-1-row)*w*4+col*4+northsouth] =\n                     input[(h-1-row)*w*4+col*4+northsouth] & ~south\n                  row -= 1\n                  path[path.length-1][path[path.length-1].length] = [col,row]\n                  }\n               else if (input[(h-1-row)*w*4+col*4+eastwest] & east) {\n                  input[(h-1-row)*w*4+col*4+eastwest] =\n                     input[(h-1-row)*w*4+col*4+eastwest] & ~east\n                  col += 1\n                  path[path.length-1][path[path.length-1].length] = [col,row]\n                  }\n               else if (input[(h-1-row)*w*4+col*4+eastwest] & west) {\n                  input[(h-1-row)*w*4+col*4+eastwest] =\n                     input[(h-1-row)*w*4+col*4+eastwest] & ~west\n                  col -= 1\n                  path[path.length-1][path[path.length-1].length] = [col,row]\n                  }\n               else\n                  break\n               }\n            }\n         }\n      //\n      // follow boundary starts\n      //\n      for (var row = 1; row < (h-1); ++row) {\n         col = 0\n         follow_edges(row,col)\n         col = w-1\n         follow_edges(row,col)\n         }\n      for (var col = 1; col < (w-1); ++col) {\n         row = 0\n         follow_edges(row,col)\n         row = h-1      \n         follow_edges(row,col)\n         }\n      //\n      // follow interior paths\n      //\n      for (var row = 1; row < (h-1); ++row) {\n         for (var col = 1; col < (w-1); ++col) {\n            follow_edges(row,col)\n            }\n         }\n      //\n      // vectorize path\n      //\n      var error = evt.data.error\n      var vecpath = []\n      for (var seg = 0; seg < path.length; ++seg) {\n         var x0 = path[seg][0][0]\n         var y0 = path[seg][0][1]\n         vecpath[vecpath.length] = [[x0,y0]]\n         var xsum = x0\n         var ysum = y0\n         var sum = 1\n         for (var pt = 1; pt < path[seg].length; ++pt) {\n            var xold = x\n            var yold = y\n            var x = path[seg][pt][0]\n            var y = path[seg][pt][1]\n            if (sum == 1) {\n               xsum += x\n               ysum += y\n               sum += 1\n               }\n            else {\n               var xmean = xsum/sum\n               var ymean = ysum/sum\n               var dx = xmean-x0\n               var dy = ymean-y0\n               var d = Math.sqrt(dx*dx+dy*dy)\n               var nx = dy/d\n               var ny = -dx/d\n               var l = Math.abs(nx*(x-x0)+ny*(y-y0))\n               if (l < error) {\n                  xsum += x\n                  ysum += y\n                  sum += 1\n                  }\n               else {\n                  vecpath[vecpath.length-1][vecpath[vecpath.length-1].length] = [xold,yold]\n                  x0 = xold\n                  y0 = yold\n                  xsum = xold\n                  ysum = yold\n                  sum = 1\n                  }\n               }\n            if (pt == (path[seg].length-1)) {\n               vecpath[vecpath.length-1][vecpath[vecpath.length-1].length] = [x,y]\n               }\n            }\n         }\n      //\n      // sort path\n      //\n      if ((vecpath.length > 0) && (sort == true)) {\n         var dmin = w*w+h*h\n         segmin = null\n         for (var seg = 0; seg < vecpath.length; ++seg) {\n            var x = vecpath[seg][0][0]\n            var y = vecpath[seg][0][0]\n            var d = x*x+y*y\n            if (d < dmin) {\n               dmin = d\n               segmin = seg\n               }\n            }\n         if (segmin != null) {\n            var sortpath = [vecpath[segmin]]\n            vecpath.splice(segmin,1)\n            }\n         while (vecpath.length > 0) {\n            var dmin = w*w+h*h\n            var x0 = sortpath[sortpath.length-1][sortpath[sortpath.length-1].length-1][0]\n            var y0 = sortpath[sortpath.length-1][sortpath[sortpath.length-1].length-1][1]\n            segmin = null\n            for (var seg = 0; seg < vecpath.length; ++seg) {\n               var x = vecpath[seg][0][0]\n               var y = vecpath[seg][0][1]\n               var d = (x-x0)*(x-x0)+(y-y0)*(y-y0)\n               if (d < dmin) {\n                  dmin = d\n                  segmin = seg\n                  }\n               }\n            if (segmin != null) {\n               sortpath[sortpath.length] = vecpath[segmin]\n               vecpath.splice(segmin,1)\n               }\n            }\n         }\n      else if ((vecpath.length > 0) && (sort == false))\n         sortpath = vecpath\n      else\n         sortpath = []\n      //\n      // return path\n      //\n      self.postMessage({path:sortpath})\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"421.84921872684436","left":"2803.902175733289","inputs":{},"outputs":{}},"0.7667165137781767":{"definition":"//\n// offset\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2019\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'offset'\n//\n// initialization\n//\nvar init = function() {\n   mod.offset.value = '14.999999999999998'\n   mod.distances = ''\n   }\n//\n// inputs\n//\nvar inputs = {\n   distances:{type:'F32',\n      event:function(evt){\n         mod.distances = evt.detail\n         var h = mod.distances.height\n         var w = mod.distances.width\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.height = mod.distances.height \n         ctx.canvas.width = mod.distances.width\n         if (mod.offset.value != '')\n            offset()\n         }},\n   offset:{type:'number',\n      event:function(evt){\n         mod.offset.value = evt.detail\n         if ((mod.offset.value != '') && (mod.distances != ''))\n            offset()\n         else\n            mod.distances = ''\n         }}}\n//\n// outputs\n//\nvar outputs = {\n   image:{type:'RGBA',\n      event:function(){\n         var ctx = mod.img.getContext(\"2d\")\n         var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n         mods.output(mod,'image',img)}}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen drawing canvas\n   //\n   var canvas = document.createElement('canvas')\n      canvas.width = mods.ui.canvas\n      canvas.height = mods.ui.canvas\n      canvas.style.backgroundColor = 'rgb(255,255,255)'\n      div.appendChild(canvas)\n      mod.canvas = canvas\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // offset value\n   //\n   div.appendChild(document.createTextNode('offset (pixels): '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         offset()\n         })\n      div.appendChild(input)\n      mod.offset = input\n   //\n   // view button\n   //\n   div.appendChild(document.createElement('br'))\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var canvas = document.createElement('canvas')\n            canvas.width = mod.img.width\n            canvas.height = mod.img.height\n            win.document.body.appendChild(canvas)\n         var ctx = canvas.getContext(\"2d\")\n            ctx.drawImage(mod.img,0,0)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// offset\n//\nfunction offset() {\n   var blob = new Blob(['('+worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      var h = mod.distances.height\n      var w = mod.distances.width\n      var buf = new Uint8ClampedArray(evt.data.buffer)\n      var imgdata = new ImageData(buf,w,h)\n      var ctx = mod.img.getContext(\"2d\")\n      ctx.putImageData(imgdata,0,0)\n      if (w > h) {\n         var x0 = 0\n         var y0 = mod.canvas.height*.5*(1-h/w)\n         var wd = mod.canvas.width\n         var hd = mod.canvas.width*h/w\n         }\n      else {\n         var x0 = mod.canvas.width*.5*(1-w/h)\n         var y0 = 0\n         var wd = mod.canvas.height*w/h\n         var hd = mod.canvas.height\n         }\n      var ctx = mod.canvas.getContext(\"2d\")\n      ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n      ctx.drawImage(mod.img,x0,y0,wd,hd)\n      webworker.terminate()\n      outputs.image.event()\n      })\n   var ctx = mod.canvas.getContext(\"2d\")\n   ctx.clearRect(0,0,mod.canvas.width,mod.canvas.height)\n   var offset = parseFloat(mod.offset.value)\n   webworker.postMessage({\n      height:mod.distances.height,width:mod.distances.width,\n      offset:offset,buffer:mod.distances.buffer})\n   }\n//\n// offset worker\n//\nfunction worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var offset = evt.data.offset\n      var input = new Float32Array(evt.data.buffer)\n      var output = new Uint8ClampedArray(4*h*w)\n      for (var row = 0; row < h; ++row) {\n         for (var col = 0; col < w; ++col) {\n            if (input[(h-1-row)*w+col] <= offset) {\n               output[(h-1-row)*w*4+col*4+0] = 255\n               output[(h-1-row)*w*4+col*4+1] = 255\n               output[(h-1-row)*w*4+col*4+2] = 255\n               output[(h-1-row)*w*4+col*4+3] = 255\n               }\n            else {\n               output[(h-1-row)*w*4+col*4+0] = 0\n               output[(h-1-row)*w*4+col*4+1] = 0\n               output[(h-1-row)*w*4+col*4+2] = 0\n               output[(h-1-row)*w*4+col*4+3] = 255\n               }\n            }\n         }\n      self.postMessage({buffer:output.buffer},[output.buffer])\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"-14.174934195322066","left":"3851.871210707966","inputs":{},"outputs":{}},"0.32304064019646705":{"definition":"//\n// mesh slice raster\n// \n// todo\n//    include slice plane triangles\n//    scale perturbation to resolution\n//\n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2018\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'mesh slice raster'\n//\n// initialization\n//\nvar init = function() {\n   mod.mmunits.value = '10'\n   mod.inunits.value = '0.3937007874015748'\n   mod.depth.value = '2.54'\n   mod.width.value = '1000'\n   mod.border.value = '0'\n   mod.delta = 1e-6\n   }\n//\n// inputs\n//\nvar inputs = {\n   mesh:{type:'STL',\n      event:function(evt){\n         mod.mesh = new DataView(evt.detail)\n         find_limits_slice()}},\n   settings:{type:'',\n      event:function(evt){\n         for (var p in evt.detail)\n            if (p == 'depthmm') {\n               mod.depth.value = evt.detail[p]\n                  /parseFloat(mod.mmunits.value)\n               }\n         find_limits_slice()}}}\n//\n// outputs\n//\nvar outputs = {\n   image:{type:'RGBA',\n      event:function(){\n         var ctx = mod.img.getContext(\"2d\")\n         var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n         mods.output(mod,'image',img)\n         }},\n   imageInfo:{type:'',\n      event:function(){\n         var obj = {}\n         obj.name = \"mesh slice raster\"\n         obj.width = mod.img.width\n         obj.height = mod.img.height\n         obj.dpi = mod.img.width/(mod.dx*parseFloat(mod.inunits.value))\n         mods.output(mod,'imageInfo',obj)\n         }}}\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // on-screen slice canvas\n   //\n   div.appendChild(document.createTextNode(' '))\n   var canvas = document.createElement('canvas')\n      canvas.width = mods.ui.canvas\n      canvas.height = mods.ui.canvas\n      canvas.style.backgroundColor = 'rgb(255,255,255)'\n      div.appendChild(canvas)\n      mod.slicecanvas = canvas\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   //\n   // mesh units\n   //\n   div.appendChild(document.createTextNode('mesh units: (enter)'))\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mm: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         mod.inunits.value = parseFloat(mod.mmunits.value)/25.4\n         find_limits_slice()\n         })\n      div.appendChild(input)\n      mod.mmunits = input\n   div.appendChild(document.createTextNode(' in: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         mod.mmunits.value = parseFloat(mod.inunits.value)*25.4\n         find_limits_slice()\n         })\n      div.appendChild(input)\n      mod.inunits = input\n   //\n   // mesh size\n   //\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mesh size:'))\n   div.appendChild(document.createElement('br'))\n   var text = document.createTextNode('XxYxZ (units)')\n      div.appendChild(text)\n      mod.meshsize = text\n   div.appendChild(document.createElement('br'))\n   var text = document.createTextNode('XxYxZ (mm)')\n      div.appendChild(text)\n      mod.mmsize = text\n   div.appendChild(document.createElement('br'))\n   var text = document.createTextNode('XxYxZ (in)')\n      div.appendChild(text)\n      mod.insize = text\n   //\n   // slice depth\n   //\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('slice Z depth: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         find_limits_slice()\n         })\n      div.appendChild(input)\n      mod.depth = input\n   div.appendChild(document.createTextNode(' (units)'))\n   //\n   // slice border \n   //\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('slice border: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         find_limits_slice()\n         })\n      div.appendChild(input)\n      mod.border = input\n   div.appendChild(document.createTextNode(' (units)'))\n   //\n   // slice width\n   //\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('slice width: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('change',function(){\n         find_limits_slice()\n         })\n      div.appendChild(input)\n      mod.width = input\n   div.appendChild(document.createTextNode(' (pixels)'))\n   //\n   // view slice\n   //\n   div.appendChild(document.createElement('br'))\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view slice'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var canvas = document.createElement('canvas')\n            canvas.width = mod.img.width\n            canvas.height = mod.img.height\n            win.document.body.appendChild(canvas)\n         var ctx = canvas.getContext(\"2d\")\n            ctx.drawImage(mod.img,0,0)\n         })\n      div.appendChild(btn)\n   }\n//\n// local functions\n//\n// find limits then slice\n//\nfunction find_limits_slice() {\n   var blob = new Blob(['('+limits_worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      mod.triangles = evt.data.triangles\n      mod.xmin = evt.data.xmin\n      mod.xmax = evt.data.xmax\n      mod.ymin = evt.data.ymin\n      mod.ymax = evt.data.ymax\n      mod.zmin = evt.data.zmin\n      mod.zmax = evt.data.zmax\n      mod.dx = mod.xmax-mod.xmin\n      mod.dy = mod.ymax-mod.ymin\n      mod.dz = mod.zmax-mod.zmin\n      mod.meshsize.nodeValue = \n         mod.dx.toFixed(3)+' x '+\n         mod.dy.toFixed(3)+' x '+\n         mod.dz.toFixed(3)+' (units)'\n      var mm = parseFloat(mod.mmunits.value)\n      mod.mmsize.nodeValue = \n         (mod.dx*mm).toFixed(3)+' x '+\n         (mod.dy*mm).toFixed(3)+' x '+\n         (mod.dz*mm).toFixed(3)+' (mm)'\n      var inches = parseFloat(mod.inunits.value)\n      mod.insize.nodeValue = \n         (mod.dx*inches).toFixed(3)+' x '+\n         (mod.dy*inches).toFixed(3)+' x '+\n         (mod.dz*inches).toFixed(3)+' (in)'\n      mods.fit(mod.div)\n      slice_mesh()\n      })\n   var border = parseFloat(mod.border.value)\n   webworker.postMessage({\n      mesh:mod.mesh,\n      border:border,delta:mod.delta})\n   }\nfunction limits_worker() {\n   self.addEventListener('message',function(evt) {\n      var view = evt.data.mesh\n      var depth = evt.data.depth\n      var border = evt.data.border\n      var delta = evt.data.delta // perturb to remove degeneracies\n      //\n      // get vars\n      //\n      var endian = true\n      var triangles = view.getUint32(80,endian)\n      var size = 80+4+triangles*(4*12+2)\n      //\n      // find limits\n      //\n      var offset = 80+4\n      var x0,x1,x2,y0,y1,y2,z0,z1,z2\n      var xmin = Number.MAX_VALUE\n      var xmax = -Number.MAX_VALUE\n      var ymin = Number.MAX_VALUE\n      var ymax = -Number.MAX_VALUE\n      var zmin = Number.MAX_VALUE\n      var zmax = -Number.MAX_VALUE\n      for (var t = 0; t < triangles; ++t) {\n         offset += 3*4\n         x0 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         y0 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         z0 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         x1 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         y1 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         z1 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         x2 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         y2 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         z2 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         offset += 2\n         if (x0 > xmax) xmax = x0\n         if (x0 < xmin) xmin = x0\n         if (y0 > ymax) ymax = y0\n         if (y0 < ymin) ymin = y0\n         if (z0 > zmax) zmax = z0\n         if (z0 < zmin) zmin = z0\n         if (x1 > xmax) xmax = x1\n         if (x1 < xmin) xmin = x1\n         if (y1 > ymax) ymax = y1\n         if (y1 < ymin) ymin = y1\n         if (z1 > zmax) zmax = z1\n         if (z1 < zmin) zmin = z1\n         if (x2 > xmax) xmax = x2\n         if (x2 < xmin) xmin = x2\n         if (y2 > ymax) ymax = y2\n         if (y2 < ymin) ymin = y2\n         if (z2 > zmax) zmax = z2\n         if (z2 < zmin) zmin = z2\n         }\n      xmin -= border\n      xmax += border\n      ymin -= border\n      ymax += border\n      //\n      // return\n      //\n      self.postMessage({triangles:triangles,\n         xmin:xmin,xmax:xmax,ymin:ymin,ymax:ymax,\n         zmin:zmin,zmax:zmax})\n      self.close()\n      })\n   }\n//\n// slice mesh\n//   \nfunction slice_mesh() {\n   var blob = new Blob(['('+slice_worker.toString()+'())'])\n   var url = window.URL.createObjectURL(blob)\n   var webworker = new Worker(url)\n   webworker.addEventListener('message',function(evt) {\n      window.URL.revokeObjectURL(url)\n      var h = mod.img.height\n      var w = mod.img.width\n      var buf = new Uint8ClampedArray(evt.data.buffer)\n      var imgdata = new ImageData(buf,w,h)\n      var ctx = mod.img.getContext(\"2d\")\n      ctx.putImageData(imgdata,0,0)\n      if (w > h) {\n         var x0 = 0\n         var y0 = mod.slicecanvas.height*.5*(1-h/w)\n         var wd = mod.slicecanvas.width\n         var hd = mod.slicecanvas.width*h/w\n         }\n      else {\n         var x0 = mod.slicecanvas.width*.5*(1-w/h)\n         var y0 = 0\n         var wd = mod.slicecanvas.height*w/h\n         var hd = mod.slicecanvas.height\n         }\n      var ctx = mod.slicecanvas.getContext(\"2d\")\n      ctx.clearRect(0,0,mod.slicecanvas.width,mod.slicecanvas.height)\n      ctx.drawImage(mod.img,x0,y0,wd,hd)\n      outputs.image.event()\n      outputs.imageInfo.event()\n      })\n   var ctx = mod.slicecanvas.getContext(\"2d\")\n   ctx.clearRect(0,0,mod.slicecanvas.width,mod.slicecanvas.height)\n   var depth = parseFloat(mod.depth.value)\n   mod.img.width = parseInt(mod.width.value)\n   mod.img.height = Math.round(mod.img.width*mod.dy/mod.dx)\n   var ctx = mod.img.getContext(\"2d\")\n   var img = ctx.getImageData(0,0,mod.img.width,mod.img.height)\n   webworker.postMessage({\n      height:mod.img.height,width:mod.img.width,depth:depth,\n      imgbuffer:img.data.buffer,mesh:mod.mesh,\n      xmin:mod.xmin,xmax:mod.xmax,\n      ymin:mod.ymin,ymax:mod.ymax,\n      zmin:mod.zmin,zmax:mod.zmax,\n      delta:mod.delta},\n      [img.data.buffer])\n   }\nfunction slice_worker() {\n   self.addEventListener('message',function(evt) {\n      var h = evt.data.height\n      var w = evt.data.width\n      var depth = evt.data.depth\n      var view = evt.data.mesh\n      var delta = evt.data.delta // perturb to remove degeneracies\n      var xmin = evt.data.xmin\n      var xmax = evt.data.xmax\n      var ymin = evt.data.ymin\n      var ymax = evt.data.ymax\n      var zmin = evt.data.zmin\n      var zmax = evt.data.zmax\n      var buf = new Uint8ClampedArray(evt.data.imgbuffer)\n      //\n      // get vars from buffer\n      //\n      var endian = true\n      var triangles = view.getUint32(80,endian)\n      var size = 80+4+triangles*(4*12+2)\n      //\n      // initialize slice image\n      //\n      for (var row = 0; row < h; ++row) {\n         for (var col = 0; col < w; ++col) {\n            buf[(h-1-row)*w*4+col*4+0] = 0\n            buf[(h-1-row)*w*4+col*4+1] = 0\n            buf[(h-1-row)*w*4+col*4+2] = 0\n            buf[(h-1-row)*w*4+col*4+3] = 255\n            }\n         }\n      //\n      // find triangles crossing the slice\n      //\n      var segs = []\n      offset = 80+4\n      for (var t = 0; t < triangles; ++t) {\n         offset += 3*4\n         x0 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         y0 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         z0 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         x1 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         y1 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         z1 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         x2 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         y2 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         z2 = view.getFloat32(offset,endian)+delta\n         offset += 4\n         //\n         // assemble vertices\n         //\n         offset += 2\n         var v = [[x0,y0,z0],[x1,y1,z1],[x2,y2,z2]]\n         //\n         // sort z\n         //\n         v.sort(function(a,b) {\n            if (a[2] < b[2])\n               return -1\n            else if (a[2] > b[2])\n               return 1\n            else\n               return 0\n            })\n         //\n         // check for crossings\n         //\n         if ((v[0][2] < (zmax-depth)) && (v[2][2] > (zmax-depth))) {\n            //\n            //  crossing found, check for side and save\n            //\n            if (v[1][2] < (zmax-depth)) {\n               var x0 = v[2][0]+(v[0][0]-v[2][0])\n                  *(v[2][2]-(zmax-depth))/(v[2][2]-v[0][2])\n               var y0 = v[2][1]+(v[0][1]-v[2][1])\n                  *(v[2][2]-(zmax-depth))/(v[2][2]-v[0][2])\n               var x1 = v[2][0]+(v[1][0]-v[2][0])\n                  *(v[2][2]-(zmax-depth))/(v[2][2]-v[1][2])\n               var y1 = v[2][1]+(v[1][1]-v[2][1])\n                  *(v[2][2]-(zmax-depth))/(v[2][2]-v[1][2])\n               }\n            else if (v[1][2] >= (zmax-depth)) {\n               var x0 = v[2][0]+(v[0][0]-v[2][0])\n                  *(v[2][2]-(zmax-depth))/(v[2][2]-v[0][2])\n               var y0 = v[2][1]+(v[0][1]-v[2][1])\n                  *(v[2][2]-(zmax-depth))/(v[2][2]-v[0][2])\n               var x1 = v[1][0]+(v[0][0]-v[1][0])\n                  *(v[1][2]-(zmax-depth))/(v[1][2]-v[0][2])\n               var y1 = v[1][1]+(v[0][1]-v[1][1])\n                  *(v[1][2]-(zmax-depth))/(v[1][2]-v[0][2])\n               }\n            if (y0 < y1)\n               segs.push({x0:x0,y0:y0,x1:x1,y1:y1})\n            else\n               segs.push({x0:x1,y0:y1,x1:x0,y1:y0})\n            }\n         }\n      //\n      // fill interior\n      //\n      for (var row = 0; row < h; ++row) {\n         var y = ymin+(ymax-ymin)*row/(h-1)\n         rowsegs = segs.filter(p => ((p.y0 <= y) && (p.y1 >= y)))\n         var xs = rowsegs.map(p =>\n            (p.x0+(p.x1-p.x0)*(y-p.y0)/(p.y1-p.y0)))\n         xs.sort((a,b) => (a-b))\n         for (var col = 0; col < w; ++col) {\n            var x = xmin+(xmax-xmin)*col/(w-1)\n            var index = xs.findIndex((p) => (p >= x))\n            if (index == -1)\n               var i = 0\n            else\n               var i = 255*(index%2)\n            buf[(h-1-row)*w*4+col*4+0] = i\n            buf[(h-1-row)*w*4+col*4+1] = i\n            buf[(h-1-row)*w*4+col*4+2] = i\n            buf[(h-1-row)*w*4+col*4+3] = 255\n            }\n         }\n      //\n      // output the slice\n      //\n      self.postMessage({buffer:buf.buffer},[buf.buffer])\n      self.close()\n      })\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n","top":"-119.80999601321696","left":"2214.1352903786023","inputs":{},"outputs":{}},"0.9325875387173613":{"definition":"//\n// mill raster 2.5D\n//\n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2019\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function(){\n//\n// module globals\n//\nvar mod = {}\n//\n// name\n//\nvar name = 'mill raster 2.5D'\n//\n// initialization\n//\nvar init = function() {\n   mod.dia_in.value = '0.11811023622047245'\n   mod.dia_mm.value = '3'\n   mod.cut_in.value = '0.11811023622047245'\n   mod.cut_mm.value = '3'\n   mod.max_in.value = '1'\n   mod.max_mm.value = '25.4'\n   mod.number.value = '1'\n   mod.stepover.value = '0.5'\n   mod.merge.value = '1'\n   mod.sort.checked = true\n   }\n//\n// inputs\n//\nvar inputs = {\n   imageInfo:{type:'',\n      event:function(evt){\n         mod.name = evt.detail.name\n         mod.dpi = evt.detail.dpi\n         mod.width = evt.detail.width\n         mod.height = evt.detail.height\n         var ctx = mod.img.getContext(\"2d\")\n         ctx.canvas.width = mod.width\n         ctx.canvas.height = mod.height\n         }},\n   path:{type:'',\n      event:function(evt){\n         if (mod.label.nodeValue == 'calculating') {\n            //\n            // calculation in progress, draw and accumulate\n            //\n            draw_path(evt.detail)\n            accumulate_path(evt.detail)\n            mod.offsetCount += 1\n            if ((mod.offsetCount != parseInt(mod.number.value))\n               && (evt.detail.length > 0)) {\n               //\n               // layer detail present and offset not complete\n               //\n               mod.offset += parseFloat(mod.stepover.value)\n               outputs.offset.event(\n                  mod.offset*parseFloat(mod.dia_in.value)*mod.dpi)\n               }\n            else if (mod.depthmm < parseFloat(mod.max_mm.value)) {\n               //\n               // layer loop not complete\n               //\n               merge_layer()\n               accumulate_toolpath()\n               clear_layer()\n               mod.depthmm += parseFloat(mod.cut_mm.value)\n               if (mod.depthmm > parseFloat(mod.max_mm.value)) {\n                  mod.depthmm = parseFloat(mod.max_mm.value)\n                  }\n               //\n               // clear offset\n               //\n               outputs.offset.event('')\n               //\n               // set new depth\n               //\n               outputs.depth.event(mod.depthmm)\n               //\n               // set new offset\n               //\n               mod.offsetCount = 0\n               outputs.offset.event(\n                  mod.offset*parseFloat(mod.dia_in.value)*mod.dpi)\n               }\n            else {\n               //\n               // done, finish and output\n               //\n               draw_path(mod.toolpath)\n               draw_connections(mod.toolpath)\n               mod.label.nodeValue = 'calculate'\n               mod.labelspan.style.fontWeight = 'normal'\n               outputs.toolpath.event()\n               }\n            }\n         }\n      },\n   settings:{type:'',\n      event:function(evt){\n         set_values(evt.detail)\n         }\n      }\n   }\n//\n// outputs\n//\nvar outputs = {\n   depth:{type:'',\n      event:function(depth){\n         mods.output(mod,'depth',{depthmm:depth})\n         }\n      },\n   diameter:{type:'',\n      event:function(){\n         mods.output(mod,'diameter',Math.ceil(mod.dpi*mod.dia_in.value))\n         }\n      },\n   offset:{type:'',\n      event:function(size){\n         mods.output(mod,'offset',size)\n         }\n      },\n   toolpath:{type:'',\n      event:function(){\n         cmd = {}\n         cmd.path = mod.toolpath\n         cmd.name = mod.name\n         cmd.dpi = mod.dpi\n         cmd.width = mod.width\n         cmd.height = mod.height\n         cmd.depth = Math.round(parseFloat(mod.max_in.value)*mod.dpi)\n         mods.output(mod,'toolpath',cmd)\n         }\n      }\n   }\n//\n// interface\n//\nvar interface = function(div){\n   mod.div = div\n   //\n   // tool diameter\n   //\n   div.appendChild(document.createTextNode('tool diameter'))\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mm: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.dia_in.value = parseFloat(mod.dia_mm.value)/25.4\n         })\n      div.appendChild(input)\n      mod.dia_mm = input\n   div.appendChild(document.createTextNode(' in: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.dia_mm.value = parseFloat(mod.dia_in.value)*25.4\n         })\n      div.appendChild(input)\n      mod.dia_in = input\n   div.appendChild(document.createElement('br'))\n   //\n   // cut depth\n   //\n   div.appendChild(document.createTextNode('cut depth'))\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mm: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.cut_in.value = parseFloat(mod.cut_mm.value)/25.4\n         })\n      div.appendChild(input)\n      mod.cut_mm = input\n   div.appendChild(document.createTextNode(' in: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.cut_mm.value = parseFloat(mod.cut_in.value)*25.4\n         })\n      div.appendChild(input)\n      mod.cut_in = input\n   div.appendChild(document.createElement('br'))\n   //\n   // max depth\n   //\n   div.appendChild(document.createTextNode('max depth'))\n   div.appendChild(document.createElement('br'))\n   div.appendChild(document.createTextNode('mm: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.max_in.value = parseFloat(mod.max_mm.value)/25.4\n         })\n      div.appendChild(input)\n      mod.max_mm = input\n   div.appendChild(document.createTextNode(' in: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      input.addEventListener('input',function(){\n         mod.max_mm.value = parseFloat(mod.max_in.value)*25.4\n         })\n      div.appendChild(input)\n      mod.max_in = input\n   div.appendChild(document.createElement('br'))\n   //\n   // offset number\n   //\n   div.appendChild(document.createTextNode('offset number: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      div.appendChild(input)\n      mod.number = input\n   div.appendChild(document.createTextNode(' (0 = fill)'))\n   div.appendChild(document.createElement('br'))\n   //\n   // offset stepover\n   //\n   div.appendChild(document.createTextNode('offset stepover: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      div.appendChild(input)\n      mod.stepover = input\n   div.appendChild(document.createTextNode(' (1 = diameter)'))\n   div.appendChild(document.createElement('br'))\n   //\n   // direction\n   //\n   div.appendChild(document.createTextNode('direction: '))\n   div.appendChild(document.createTextNode('climb'))\n   var input = document.createElement('input')\n      input.type = 'radio'\n      input.name = mod.div.id+'direction'\n      input.id = mod.div.id+'climb'\n      input.checked = true\n      div.appendChild(input)\n      mod.climb = input\n   div.appendChild(document.createTextNode(' conventional'))\n   var input = document.createElement('input')\n      input.type = 'radio'\n      input.name = mod.div.id+'direction'\n      input.id = mod.div.id+'conventional'\n      div.appendChild(input)\n      mod.conventional = input\n   div.appendChild(document.createElement('br'))\n   //\n   // path merge\n   //\n   div.appendChild(document.createTextNode('path merge: '))\n   var input = document.createElement('input')\n      input.type = 'text'\n      input.size = 6\n      div.appendChild(input)\n      mod.merge = input\n   div.appendChild(document.createTextNode(' (1 = diameter)'))\n   div.appendChild(document.createElement('br'))\n   //\n   // path order\n   //\n   div.appendChild(document.createTextNode('path order: '))\n   div.appendChild(document.createTextNode('forward'))\n   var input = document.createElement('input')\n      input.type = 'radio'\n      input.name = mod.div.id+'order'\n      input.id = mod.div.id+'forward'\n      input.checked = true\n      div.appendChild(input)\n      mod.forward = input\n   div.appendChild(document.createTextNode(' reverse'))\n   var input = document.createElement('input')\n      input.type = 'radio'\n      input.name = mod.div.id+'order'\n      input.id = mod.div.id+'reverse'\n      div.appendChild(input)\n      mod.reverse = input\n   div.appendChild(document.createElement('br'))\n   //\n   // sort distance\n   //\n   div.appendChild(document.createTextNode('sort distance: '))\n   var input = document.createElement('input')\n      input.type = 'checkbox'\n      input.id = mod.div.id+'sort'\n      div.appendChild(input)\n      mod.sort = input\n   div.appendChild(document.createElement('br'))\n   //\n   // calculate\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      var span = document.createElement('span')\n         var text = document.createTextNode('calculate')\n            mod.label = text\n            span.appendChild(text)\n         mod.labelspan = span\n         btn.appendChild(span)\n      btn.addEventListener('click',function(){\n         mod.label.nodeValue = 'calculating'\n         mod.labelspan.style.fontWeight = 'bold'\n         outputs.offset.event('') // clear offset\n         mod.depthmm = parseFloat(mod.cut_mm.value)\n         outputs.depth.event(mod.depthmm) // set depth\n         mod.toolpath = [] // start new toolpath\n         clear_layer() // clear layer\n         outputs.diameter.event()\n         outputs.offset.event( // set offset\n            mod.offset*parseFloat(mod.dia_in.value)*mod.dpi)\n         })\n      div.appendChild(btn)\n   div.appendChild(document.createTextNode(' '))\n   //\n   // view\n   //\n   var btn = document.createElement('button')\n      btn.style.padding = mods.ui.padding\n      btn.style.margin = 1\n      btn.appendChild(document.createTextNode('view'))\n      btn.addEventListener('click',function(){\n         var win = window.open('')\n         var btn = document.createElement('button')\n            btn.appendChild(document.createTextNode('close'))\n            btn.style.padding = mods.ui.padding\n            btn.style.margin = 1\n            btn.addEventListener('click',function(){\n               win.close()\n               })\n            win.document.body.appendChild(btn)\n         win.document.body.appendChild(document.createElement('br'))\n         var svg = document.getElementById(mod.div.id+'svg')\n         var clone = svg.cloneNode(true)\n         clone.setAttribute('width',mod.img.width)\n         clone.setAttribute('height',mod.img.height)\n         win.document.body.appendChild(clone)\n         })\n      div.appendChild(btn)\n   div.appendChild(document.createElement('br'))\n   //\n   // on-screen SVG\n   //\n   var svgNS = \"http://www.w3.org/2000/svg\"\n   var svg = document.createElementNS(svgNS,\"svg\")\n   svg.setAttribute('id',mod.div.id+'svg')\n   svg.setAttributeNS(\"http://www.w3.org/2000/xmlns/\",\n      \"xmlns:xlink\",\"http://www.w3.org/1999/xlink\")\n   svg.setAttribute('width',mods.ui.canvas)\n   svg.setAttribute('height',mods.ui.canvas)\n   svg.style.backgroundColor = 'rgb(255,255,255)'\n   var g = document.createElementNS(svgNS,'g')\n   g.setAttribute('id',mod.div.id+'g')\n   svg.appendChild(g)\n   div.appendChild(svg)\n   div.appendChild(document.createElement('br'))\n   //\n   // off-screen image canvas\n   //\n   var canvas = document.createElement('canvas')\n      mod.img = canvas\n   }\n//\n// local functions\n//\n// set_values\n//\nfunction set_values(settings) {\n   for (var s in settings) {\n      switch(s) {\n         case 'tool diameter (in)':\n            mod.dia_in.value = settings[s]\n            mod.dia_mm.value = parseFloat(mod.dia_in.value)*25.4\n            break\n         case 'cut depth (in)':\n            mod.cut_in.value = settings[s]\n            mod.cut_mm.value = parseFloat(mod.cut_in.value)*25.4\n            break\n         case 'max depth (in)':\n            mod.max_in.value = settings[s]\n            mod.max_mm.value = parseFloat(mod.max_in.value)*25.4\n            break\n         case 'offset number':\n            mod.number.value = settings[s]\n            break\n         }\n      }\n   }\n//\n// clear_layer\n//\nfunction clear_layer() {\n   mod.path = []\n   mod.offset = 0.5\n   mod.offsetCount = 0\n   var svg = document.getElementById(mod.div.id+'svg')\n   svg.setAttribute(\n      'viewBox',\"0 0 \"+(mod.img.width-1)+\" \"+(mod.img.height-1))\n   var g = document.getElementById(mod.div.id+'g')\n   svg.removeChild(g)\n   var g = document.createElementNS('http://www.w3.org/2000/svg','g')\n   g.setAttribute('id',mod.div.id+'g')\n   svg.appendChild(g)\n   }\n//\n// accumulate_path\n//    todo: replace inefficient insertion sort\n//    todo: move sort out of main thread\n//\nfunction accumulate_path(path) {\n   var forward = mod.forward.checked\n   var conventional = mod.conventional.checked\n   var sort = mod.sort.checked\n   for (var segnew = 0; segnew < path.length; ++segnew) {\n      if (conventional)\n         path[segnew].reverse()\n      if (mod.path.length == 0)\n         mod.path.splice(0,0,path[segnew])\n      else if (sort) {\n         var xnew = path[segnew][0][0]\n         var ynew = path[segnew][0][1]\n         var dmin = Number.MAX_VALUE\n         var segmin = -1\n         for (var segold = 0; segold < mod.path.length; ++segold) {\n            var xold = mod.path[segold][0][0]\n            var yold = mod.path[segold][0][1]\n            var dx = xnew-xold\n            var dy = ynew-yold\n            var d = Math.sqrt(dx*dx+dy*dy)\n            if (d < dmin) {\n               dmin = d\n               segmin = segold\n               }\n            }\n         if (forward)\n            mod.path.splice(segmin+1,0,path[segnew])\n         else\n            mod.path.splice(segmin,0,path[segnew])\n         }\n      else {\n         if (forward)\n            mod.path.splice(mod.path.length,0,path[segnew])\n         else\n            mod.path.splice(0,0,path[segnew])\n         }\n      }\n   }\n//\n// merge_layer\n//\nfunction merge_layer() {\n   var dmerge = mod.dpi*parseFloat(mod.merge.value)*parseFloat(mod.dia_in.value)\n   var seg = 0\n   while (seg < (mod.path.length-1)) {\n      var xold = mod.path[seg][mod.path[seg].length-1][0]\n      var yold = mod.path[seg][mod.path[seg].length-1][1]\n      var xnew = mod.path[seg+1][0][0]\n      var ynew = mod.path[seg+1][0][1]\n      var dx = xnew-xold\n      var dy = ynew-yold\n      var d = Math.sqrt(dx*dx+dy*dy)\n      if (d < dmerge)\n         mod.path.splice(seg,2,mod.path[seg].concat(mod.path[seg+1]))\n      else\n         seg += 1\n      }\n   }\n//\n// accumulate_toolpath\n//\nfunction accumulate_toolpath() {\n   for (var seg = 0; seg < mod.path.length; ++seg) {\n      var newseg = []\n      for (var pt = 0; pt < mod.path[seg].length; ++pt) {\n         var idepth = -Math.round(mod.dpi*mod.depthmm/25.4)\n         var point = mod.path[seg][pt].concat(idepth)\n         newseg.splice(newseg.length,0,point)\n         }\n      mod.toolpath.push(newseg)\n      }\n   }\n//\n// draw_path\n//\nfunction draw_path(path) {\n   var g = document.getElementById(mod.div.id+'g')\n   var h = mod.img.height\n   var w = mod.img.width\n   var xend = null\n   var yend = null\n   //\n   // loop over segments\n   //\n   for (var segment = 0; segment < path.length; ++segment) {\n      if (path[segment].length > 1) {\n         //\n         // loop over points\n         //\n         for (var point = 1; point < path[segment].length; ++point) {\n            var line = document.createElementNS(\n               'http://www.w3.org/2000/svg','line')\n            line.setAttribute('stroke','black')\n            line.setAttribute('stroke-width',1)\n            line.setAttribute('stroke-linecap','round')\n            var x1 = path[segment][point-1][0]\n            var y1 = h-path[segment][point-1][1]-1\n            var x2 = path[segment][point][0]\n            var y2 = h-path[segment][point][1]-1\n            xend = x2\n            yend = y2\n            line.setAttribute('x1',x1)\n            line.setAttribute('y1',y1)\n            line.setAttribute('x2',x2)\n            line.setAttribute('y2',y2)\n            var dx = x2-x1\n            var dy = y2-y1\n            var d = Math.sqrt(dx*dx+dy*dy)\n            if (d > 0) {\n               nx = 6*dx/d\n               ny = 6*dy/d\n               var tx = 3*dy/d\n               var ty = -3*dx/d\n               g.appendChild(line)\n               triangle = document.createElementNS(\n                  'http://www.w3.org/2000/svg','polygon')\n               triangle.setAttribute(\n                  'points',x2+','+y2+' '+(x2-nx+tx)+','+(y2-ny+ty)\n                  +' '+(x2-nx-tx)+','+(y2-ny-ty))\n               triangle.setAttribute('fill','black')\n               g.appendChild(triangle)\n               }\n            }\n         }\n      }\n   }\n//\n// draw_connections\n//\nfunction draw_connections(path) {\n   var g = document.getElementById(mod.div.id+'g')\n   var h = mod.img.height\n   var w = mod.img.width\n   //\n   // loop over segments\n   //\n   for (var segment = 1; segment < path.length; ++segment) {\n      //\n      // draw connection from previous segment\n      //\n      var line = document.createElementNS(\n         'http://www.w3.org/2000/svg','line')\n      line.setAttribute('stroke','red')\n      line.setAttribute('stroke-width',1)\n      line.setAttribute('stroke-linecap','round')\n      var x1 = path[segment-1][path[segment-1].length-1][0]\n      var y1 = h-path[segment-1][path[segment-1].length-1][1]-1\n      var x2 = path[segment][0][0]\n      var y2 = h-path[segment][0][1]-1\n      line.setAttribute('x1',x1)\n      line.setAttribute('y1',y1)\n      line.setAttribute('x2',x2)\n      line.setAttribute('y2',y2)\n      var dx = x2-x1\n      var dy = y2-y1\n      var d = Math.sqrt(dx*dx+dy*dy)\n      if (d > 0) {\n         nx = 6*dx/d\n         ny = 6*dy/d\n         var tx = 3*dy/d\n         var ty = -3*dx/d\n         g.appendChild(line)\n         triangle = document.createElementNS(\n            'http://www.w3.org/2000/svg','polygon')\n         triangle.setAttribute(\n            'points',x2+','+y2+' '+(x2-nx+tx)+','+(y2-ny+ty)\n            +' '+(x2-nx-tx)+','+(y2-ny-ty))\n         triangle.setAttribute('fill','red')\n         g.appendChild(triangle)\n         }\n      }\n   }\n//\n// return values\n//\nreturn ({\n   mod:mod,\n   name:name,\n   init:init,\n   inputs:inputs,\n   outputs:outputs,\n   interface:interface\n   })\n}())\n\n","top":"540.6521981610651","left":"2208.2259536608576","inputs":{},"outputs":{}},"0.992597256007513":{"definition":"//\n// mesh rotate\n// \n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2018\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'mesh rotate'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.rx.value = 0\n        mod.ry.value = 0\n        mod.rz.value = 0\n    }\n    //\n    // inputs\n    //\n    var inputs = {\n        mesh: {\n            type: 'STL',\n            event: function(evt) {\n                mod.mesh = evt.detail\n                rotate_mesh()\n            }\n        }\n    }\n    //\n    // outputs\n    //\n    var outputs = {\n        mesh: {\n            type: 'STL',\n            event: function(buffer) {\n                mods.output(mod, 'mesh', buffer)\n            }\n        }\n    }\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //\n        // canvas\n        //\n        var canvas = document.createElement('canvas')\n        canvas.width = mods.ui.canvas\n        canvas.height = mods.ui.canvas\n        canvas.style.backgroundColor = 'rgb(255,255,255)'\n        div.appendChild(canvas)\n        mod.canvas = canvas\n        div.appendChild(document.createElement('br'))\n        //\n        // rotation\n        //\n        div.appendChild(document.createTextNode('rotation (degrees):'))\n        div.appendChild(document.createElement('br'))\n        div.appendChild(document.createTextNode(' x: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        input.addEventListener('change', function() {\n            rotate_mesh()\n        })\n        div.appendChild(input)\n        mod.rx = input\n        div.appendChild(document.createTextNode(' y: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        input.addEventListener('change', function() {\n            rotate_mesh()\n        })\n        div.appendChild(input)\n        mod.ry = input\n        div.appendChild(document.createElement('br'))\n        div.appendChild(document.createTextNode(' z: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        input.addEventListener('change', function() {\n            rotate_mesh()\n        })\n        div.appendChild(input)\n        mod.rz = input\n        div.appendChild(document.createTextNode(' (enter)'))\n        div.appendChild(document.createElement('br'))\n        //\n        // info\n        //\n        var text = document.createTextNode('dx:')\n        div.appendChild(text)\n        mod.dxn = text\n        div.appendChild(document.createElement('br'))\n        var text = document.createTextNode('dy:')\n        div.appendChild(text)\n        mod.dyn = text\n        div.appendChild(document.createElement('br'))\n        var text = document.createTextNode('dz:')\n        div.appendChild(text)\n        mod.dzn = text\n        div.appendChild(document.createElement('br'))\n    }\n    //\n    // local functions\n    //\n    // rotate mesh\n    //\n    function rotate_mesh() {\n        //\n        // check for binary STL\n        //\n        var endian = true\n        var view = new DataView(mod.mesh)\n        var triangles = view.getUint32(80, endian)\n        var size = 80 + 4 + triangles * (4 * 12 + 2)\n        //\n        // find limits, rotate, and draw\n        //\n        var blob = new Blob(['(' + rotate_mesh_worker.toString() + '())'])\n        var url = window.URL.createObjectURL(blob)\n        var webworker = new Worker(url)\n        webworker.addEventListener('message', function(evt) {\n            //\n            // worker response\n            //\n            window.URL.revokeObjectURL(url)\n            //\n            // size\n            //\n            mod.dxn.nodeValue = 'dx: ' + evt.data.dx.toFixed(3)\n            mod.dyn.nodeValue = 'dy: ' + evt.data.dy.toFixed(3)\n            mod.dzn.nodeValue = 'dz: ' + evt.data.dz.toFixed(3)\n            //\n            // image\n            //\n            var image = evt.data.image\n            var height = mod.canvas.height\n            var width = mod.canvas.width\n            var buffer = new Uint8ClampedArray(evt.data.image)\n            var imgdata = new ImageData(buffer, width, height)\n            var ctx = mod.canvas.getContext(\"2d\")\n            ctx.putImageData(imgdata, 0, 0)\n            //\n            // mesh\n            //\n            mod.mesh = evt.data.mesh\n            //\n            // output\n            //\n            outputs.mesh.event(evt.data.rotate)\n        })\n        //\n        // call worker\n        //\n        var ctx = mod.canvas.getContext(\"2d\")\n        ctx.clearRect(0, 0, mod.canvas.width, mod.canvas.height)\n        var img = ctx.getImageData(0, 0, mod.canvas.width, mod.canvas.height)\n        var rx = parseFloat(mod.rx.value) * Math.PI / 180\n        var ry = parseFloat(mod.ry.value) * Math.PI / 180\n        var rz = parseFloat(mod.rz.value) * Math.PI / 180\n        webworker.postMessage({\n            height: mod.canvas.height,\n            width: mod.canvas.width,\n            rx: rx,\n            ry: ry,\n            rz: rz,\n            image: img.data.buffer,\n            mesh: mod.mesh\n        }, [img.data.buffer, mod.mesh])\n    }\n\n    function rotate_mesh_worker() {\n        self.addEventListener('message', function(evt) {\n            //\n            // function to draw line\n            //\n            function line(x0, y0, x1, y1) {\n                var ix0 = Math.floor(xo + xw * (x0 - xmin) / dx)\n                var iy0 = Math.floor(yo + yh * (ymax - y0) / dy)\n                var ix1 = Math.floor(xo + xw * (x1 - xmin) / dx)\n                var iy1 = Math.floor(yo + yh * (ymax - y1) / dy)\n                var row, col\n                var idx = ix1 - ix0\n                var idy = iy1 - iy0\n                if (Math.abs(idy) > Math.abs(idx)) {\n                    (idy > 0) ?\n                    (row0 = iy0, col0 = ix0, row1 = iy1, col1 = ix1) :\n                    (row0 = iy1, col0 = ix1, row1 = iy0, col1 = ix0)\n                    for (row = row0; row <= row1; ++row) {\n                        col = Math.floor(col0 + (col1 - col0) * (row - row0) / (row1 - row0))\n                        image[row * width * 4 + col * 4 + 0] = 0\n                        image[row * width * 4 + col * 4 + 1] = 0\n                        image[row * width * 4 + col * 4 + 2] = 0\n                        image[row * width * 4 + col * 4 + 3] = 255\n                    }\n                } else if ((Math.abs(idx) >= Math.abs(idy)) && (idx != 0)) {\n                    (idx > 0) ?\n                    (row0 = iy0, col0 = ix0, row1 = iy1, col1 = ix1) :\n                    (row0 = iy1, col0 = ix1, row1 = iy0, col1 = ix0)\n                    for (col = col0; col <= col1; ++col) {\n                        row = Math.floor(row0 + (row1 - row0) * (col - col0) / (col1 - col0))\n                        image[row * width * 4 + col * 4 + 0] = 0\n                        image[row * width * 4 + col * 4 + 1] = 0\n                        image[row * width * 4 + col * 4 + 2] = 0\n                        image[row * width * 4 + col * 4 + 3] = 255\n                    }\n                } else {\n                    row = iy0\n                    col = ix0\n                    image[row * width * 4 + col * 4 + 0] = 0\n                    image[row * width * 4 + col * 4 + 1] = 0\n                    image[row * width * 4 + col * 4 + 2] = 0\n                    image[row * width * 4 + col * 4 + 3] = 255\n                }\n            }\n            //\n            // function to rotate point\n            //\n            function rotate(x, y, z) {\n                var x1 = x\n                var y1 = Math.cos(rx) * y - Math.sin(rx) * z\n                var z1 = Math.sin(rx) * y + Math.cos(rx) * z\n                var x2 = Math.cos(ry) * x1 - Math.sin(ry) * z1\n                var y2 = y1\n                var z2 = Math.sin(ry) * x1 + Math.cos(ry) * z1\n                var x3 = Math.cos(rz) * x2 - Math.sin(rz) * y2\n                var y3 = Math.sin(rz) * x2 + Math.cos(rz) * y2\n                var z3 = z2\n                //return([x3,y3,z3])\n                return ({\n                    x: x3,\n                    y: y3,\n                    z: z3\n                })\n            }\n            //\n            // get variables\n            //\n            var height = evt.data.height\n            var width = evt.data.width\n            var rx = evt.data.rx\n            var ry = evt.data.ry\n            var rz = evt.data.rz\n            var endian = true\n            var image = new Uint8ClampedArray(evt.data.image)\n            var view = new DataView(evt.data.mesh)\n            var triangles = view.getUint32(80, endian)\n            //\n            // find limits\n            //\n            var offset = 80 + 4\n            var x0, x1, x2, y0, y1, y2, z0, z1, z2\n            var xmin = Number.MAX_VALUE\n            var xmax = -Number.MAX_VALUE\n            var ymin = Number.MAX_VALUE\n            var ymax = -Number.MAX_VALUE\n            var zmin = Number.MAX_VALUE\n            var zmax = -Number.MAX_VALUE\n            for (var t = 0; t < triangles; ++t) {\n                offset += 3 * 4\n                x0 = view.getFloat32(offset, endian)\n                offset += 4\n                y0 = view.getFloat32(offset, endian)\n                offset += 4\n                z0 = view.getFloat32(offset, endian)\n                offset += 4\n                x1 = view.getFloat32(offset, endian)\n                offset += 4\n                y1 = view.getFloat32(offset, endian)\n                offset += 4\n                z1 = view.getFloat32(offset, endian)\n                offset += 4\n                x2 = view.getFloat32(offset, endian)\n                offset += 4\n                y2 = view.getFloat32(offset, endian)\n                offset += 4\n                z2 = view.getFloat32(offset, endian)\n                offset += 4\n                offset += 2\n                var p0 = rotate(x0, y0, z0)\n                if (p0.x > xmax) xmax = p0.x\n                if (p0.x < xmin) xmin = p0.x\n                if (p0.y > ymax) ymax = p0.y\n                if (p0.y < ymin) ymin = p0.y\n                if (p0.z > zmax) zmax = p0.z\n                if (p0.z < zmin) zmin = p0.z\n                var p1 = rotate(x1, y1, z1)\n                if (p1.x > xmax) xmax = p1.x\n                if (p1.x < xmin) xmin = p1.x\n                if (p1.y > ymax) ymax = p1.y\n                if (p1.y < ymin) ymin = p1.y\n                if (p1.z > zmax) zmax = p1.z\n                if (p1.z < zmin) zmin = p1.z\n                var p2 = rotate(x2, y2, z2)\n                if (p2.x > xmax) xmax = p2.x\n                if (p2.x < xmin) xmin = p2.x\n                if (p2.y > ymax) ymax = p2.y\n                if (p2.y < ymin) ymin = p2.y\n                if (p2.z > zmax) zmax = p2.z\n                if (p2.z < zmin) zmin = p2.z\n            }\n            var dx = xmax - xmin\n            var dy = ymax - ymin\n            var dz = zmax - zmin\n            //\n            // copy mesh\n            //\n            var newbuf = evt.data.mesh.slice(0)\n            var newview = new DataView(newbuf)\n            //\n            // copy and draw mesh\n            //\n            if (dx > dy) {\n                var xo = 0\n                var yo = height * .5 * (1 - dy / dx)\n                var xw = (width - 1)\n                var yh = (width - 1) * dy / dx\n            } else {\n                var xo = width * .5 * (1 - dx / dy)\n                var yo = 0\n                var xw = (height - 1) * dx / dy\n                var yh = (height - 1)\n            }\n            offset = 80 + 4\n            var newoffset = 80 + 4\n            for (var t = 0; t < triangles; ++t) {\n                offset += 3 * 4\n                x0 = view.getFloat32(offset, endian)\n                offset += 4\n                y0 = view.getFloat32(offset, endian)\n                offset += 4\n                z0 = view.getFloat32(offset, endian)\n                offset += 4\n                x1 = view.getFloat32(offset, endian)\n                offset += 4\n                y1 = view.getFloat32(offset, endian)\n                offset += 4\n                z1 = view.getFloat32(offset, endian)\n                offset += 4\n                x2 = view.getFloat32(offset, endian)\n                offset += 4\n                y2 = view.getFloat32(offset, endian)\n                offset += 4\n                z2 = view.getFloat32(offset, endian)\n                offset += 4\n                offset += 2\n                var p0 = rotate(x0, y0, z0)\n                var p1 = rotate(x1, y1, z1)\n                var p2 = rotate(x2, y2, z2)\n                line(p0.x, p0.y, p1.x, p1.y)\n                line(p1.x, p1.y, p2.x, p2.y)\n                line(p2.x, p2.y, p0.x, p0.y)\n                newoffset += 3 * 4\n                newview.setFloat32(newoffset, p0.x, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p0.y, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p0.z, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p1.x, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p1.y, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p1.z, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p2.x, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p2.y, endian)\n                newoffset += 4\n                newview.setFloat32(newoffset, p2.z, endian)\n                newoffset += 4\n                newoffset += 2\n            }\n            //\n            // return results and close\n            //\n            self.postMessage({\n                dx: dx,\n                dy: dy,\n                dz: dz,\n                image: evt.data.image,\n                mesh: evt.data.mesh,\n                rotate: newbuf\n            }, [evt.data.image, evt.data.mesh, newbuf])\n            self.close()\n        })\n    }\n\n    function old_rotate_mesh() {\n        //\n        // function to rotate point\n        //\n        function rotate(x, y, z) {\n            var x1 = x\n            var y1 = Math.cos(rx) * y - Math.sin(rx) * z\n            var z1 = Math.sin(rx) * y + Math.cos(rx) * z\n            var x2 = Math.cos(ry) * x1 - Math.sin(ry) * z1\n            var y2 = y1\n            var z2 = Math.sin(ry) * x1 + Math.cos(ry) * z1\n            var x3 = Math.cos(rz) * x2 - Math.sin(rz) * y2\n            var y3 = Math.sin(rz) * x2 + Math.cos(rz) * y2\n            var z3 = z2\n            return ([x3, y3, z3])\n        }\n        //\n        // get vars\n        //\n        var view = mod.mesh\n        var endian = true\n        var triangles = view.getUint32(80, endian)\n        mod.triangles = triangles\n        var size = 80 + 4 + triangles * (4 * 12 + 2)\n        var rx = parseFloat(mod.rx.value) * Math.PI / 180\n        var ry = parseFloat(mod.ry.value) * Math.PI / 180\n        var rz = parseFloat(mod.rz.value) * Math.PI / 180\n        //\n        // find limits\n        //\n        var offset = 80 + 4\n        var x0, x1, x2, y0, y1, y2, z0, z1, z2\n        var xmin = Number.MAX_VALUE\n        var xmax = -Number.MAX_VALUE\n        var ymin = Number.MAX_VALUE\n        var ymax = -Number.MAX_VALUE\n        var zmin = Number.MAX_VALUE\n        var zmax = -Number.MAX_VALUE\n        for (var t = 0; t < triangles; ++t) {\n            offset += 3 * 4\n            x0 = view.getFloat32(offset, endian)\n            offset += 4\n            y0 = view.getFloat32(offset, endian)\n            offset += 4\n            z0 = view.getFloat32(offset, endian)\n            offset += 4\n            x1 = view.getFloat32(offset, endian)\n            offset += 4\n            y1 = view.getFloat32(offset, endian)\n            offset += 4\n            z1 = view.getFloat32(offset, endian)\n            offset += 4\n            x2 = view.getFloat32(offset, endian)\n            offset += 4\n            y2 = view.getFloat32(offset, endian)\n            offset += 4\n            z2 = view.getFloat32(offset, endian)\n            offset += 4\n            offset += 2\n            var p0 = rotate(x0, y0, z0)\n            if (p0[0] > xmax) xmax = p0[0]\n            if (p0[0] < xmin) xmin = p0[0]\n            if (p0[1] > ymax) ymax = p0[1]\n            if (p0[1] < ymin) ymin = p0[1]\n            if (p0[2] > zmax) zmax = p0[2]\n            if (p0[2] < zmin) zmin = p0[2]\n            var p1 = rotate(x1, y1, z1)\n            if (p1[0] > xmax) xmax = p1[0]\n            if (p1[0] < xmin) xmin = p1[0]\n            if (p1[1] > ymax) ymax = p1[1]\n            if (p1[1] < ymin) ymin = p1[1]\n            if (p1[2] > zmax) zmax = p1[2]\n            if (p1[2] < zmin) zmin = p1[2]\n            var p2 = rotate(x2, y2, z2)\n            if (p2[0] > xmax) xmax = p2[0]\n            if (p2[0] < xmin) xmin = p2[0]\n            if (p2[1] > ymax) ymax = p2[1]\n            if (p2[1] < ymin) ymin = p2[1]\n            if (p2[2] > zmax) zmax = p2[2]\n            if (p2[2] < zmin) zmin = p2[2]\n        }\n        mod.dx = xmax - xmin\n        mod.dy = ymax - ymin\n        mod.dz = zmax - zmin\n        mod.dxn.nodeValue = 'dx: ' + mod.dx.toFixed(3)\n        mod.dyn.nodeValue = 'dy: ' + mod.dy.toFixed(3)\n        mod.dzn.nodeValue = 'dz: ' + mod.dz.toFixed(3)\n        mod.xmin = xmin\n        mod.ymin = ymin\n        mod.zmin = zmin\n        mod.xmax = xmax\n        mod.ymax = ymax\n        mod.zmax = zmax\n        //\n        // copy mesh\n        //\n        var buf = mod.mesh.buffer.slice(0)\n        var newview = new DataView(buf)\n        //\n        // draw projection and save rotation\n        //\n        var ctx = mod.meshcanvas.getContext('2d')\n        var w = mod.meshcanvas.width\n        var h = mod.meshcanvas.height\n        ctx.clearRect(0, 0, w, h)\n        var dx = mod.dx\n        var dy = mod.dy\n        if (dx > dy) {\n            var xo = 0\n            var yo = h * .5 * (1 - dy / dx)\n            var xw = w\n            var yh = w * dy / dx\n        } else {\n            var xo = w * .5 * (1 - dx / dy)\n            var yo = 0\n            var xw = h * dx / dy\n            var yh = h\n        }\n        ctx.beginPath()\n        offset = 80 + 4\n        var newoffset = 80 + 4\n        for (var t = 0; t < triangles; ++t) {\n            offset += 3 * 4\n            x0 = view.getFloat32(offset, endian)\n            offset += 4\n            y0 = view.getFloat32(offset, endian)\n            offset += 4\n            z0 = view.getFloat32(offset, endian)\n            offset += 4\n            x1 = view.getFloat32(offset, endian)\n            offset += 4\n            y1 = view.getFloat32(offset, endian)\n            offset += 4\n            z1 = view.getFloat32(offset, endian)\n            offset += 4\n            x2 = view.getFloat32(offset, endian)\n            offset += 4\n            y2 = view.getFloat32(offset, endian)\n            offset += 4\n            z2 = view.getFloat32(offset, endian)\n            offset += 4\n            offset += 2\n            var p0 = rotate(x0, y0, z0)\n            var p1 = rotate(x1, y1, z1)\n            var p2 = rotate(x2, y2, z2)\n            x0 = xo + xw * (p0[0] - xmin) / dx\n            y0 = yo + yh * (ymax - p0[1]) / dy\n            x1 = xo + xw * (p1[0] - xmin) / dx\n            y1 = yo + yh * (ymax - p1[1]) / dy\n            x2 = xo + xw * (p2[0] - xmin) / dx\n            y2 = yo + yh * (ymax - p2[1]) / dy\n            ctx.moveTo(x0, y0)\n            ctx.lineTo(x1, y1)\n            ctx.lineTo(x2, y2)\n            ctx.lineTo(x0, y0)\n            newoffset += 3 * 4\n            newview.setFloat32(newoffset, p0[0], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p0[1], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p0[2], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p1[0], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p1[1], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p1[2], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p2[0], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p2[1], endian)\n            newoffset += 4\n            newview.setFloat32(newoffset, p2[2], endian)\n            newoffset += 4\n            newoffset += 2\n        }\n        ctx.stroke()\n        //\n        // generate output\n        //\n        outputs.mesh.event(buf)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"865.5183695424383","left":"1071.182836568586","inputs":{},"outputs":{}},"0.1693843027844284":{"definition":"//\n// label\n//\n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2018\n// Modified by Francisco Sanchez Arroyo 02-Feb-2020\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'label'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.size.value = '400'\n        mod.text.value = 'rough pass'\n        update_text()\n    }\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {}\n    //\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //div.appendChild(document.createTextNode('font size: '))\n        input = document.createElement('input')\n        input.type = 'text'\n        input.size = 3\n        input.addEventListener('input', function(evt) {\n            update_text()\n        })\n        //div.appendChild(input)\n        mod.size = input\n        //div.appendChild(document.createTextNode(' (%)'))\n        //div.appendChild(document.createElement('br'))\n        //div.appendChild(document.createTextNode('text: '))\n        input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        input.addEventListener('input', function(evt) {\n            update_text()\n        })\n        //div.appendChild(input)\n        mod.text = input\n        //div.appendChild(document.createElement('br'))\n        var span = document.createElement('span')\n        var text = document.createTextNode('')\n        span.appendChild(text)\n        mod.label = text\n        div.appendChild(span)\n        mod.span = span\n    }\n    //\n    // local functions\n    //\n    function update_text() {\n        mod.label.nodeValue = mod.text.value\n        mod.span.style.fontSize = mod.size.value + '%'\n        mods.fit(mod.div)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"657.1503750859434","left":"1934.233614498333","inputs":{},"outputs":{}},"0.02814565651522316":{"definition":"//\n// label\n//\n// Neil Gershenfeld\n// (c) Massachusetts Institute of Technology 2018\n// Modified by Francisco Sanchez Arroyo 02-Feb-2020\n//\n// This work may be reproduced, modified, distributed, performed, and\n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is\n// provided as is; no warranty is provided, and users accept all\n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'label'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.size.value = '400'\n        mod.text.value = 'finish pass'\n        update_text()\n    }\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {}\n    //\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //div.appendChild(document.createTextNode('font size: '))\n        input = document.createElement('input')\n        input.type = 'text'\n        input.size = 3\n        input.addEventListener('input', function(evt) {\n            update_text()\n        })\n        //div.appendChild(input)\n        mod.size = input\n        //div.appendChild(document.createTextNode(' (%)'))\n        //div.appendChild(document.createElement('br'))\n        //div.appendChild(document.createTextNode('text: '))\n        input = document.createElement('input')\n        input.type = 'text'\n        input.size = 6\n        input.addEventListener('input', function(evt) {\n            update_text()\n        })\n        //div.appendChild(input)\n        mod.text = input\n        //div.appendChild(document.createElement('br'))\n        var span = document.createElement('span')\n        var text = document.createTextNode('')\n        span.appendChild(text)\n        mod.label = text\n        div.appendChild(span)\n        mod.span = span\n    }\n    //\n    // local functions\n    //\n    function update_text() {\n        mod.label.nodeValue = mod.text.value\n        mod.span.style.fontSize = mod.size.value + '%'\n        mods.fit(mod.div)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"1388.3913463411525","left":"2164.894702163194","inputs":{},"outputs":{}},"0.7044752456452867":{"definition":"//\n// note\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2017\n// Modified by Francisco Sanchez 2019\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'note'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.text.value = 'STEP 1B: For the wax finish pass press calculate here. Then go to step 2.'\n    }\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {}\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //\n        // text\n        //\n        var text = document.createElement('textarea')\n        text.style.backgroundColor = '#D4E157';\n        text.setAttribute('spellcheck', 'false')\n        text.setAttribute('rows', mods.ui.rows)\n        text.setAttribute('cols', mods.ui.cols)\n        //\n        // watch textarea for resize\n        //\n        new MutationObserver(update_module).observe(text, {\n            attributes: true,\n            attributeFilter: [\"style\"]\n        })\n        div.appendChild(text)\n        mod.text = text\n        div.appendChild(document.createElement('br'))\n    }\n    //\n    // local functions\n    //\n    //\n    // update module\n    //\n    function update_module() {\n        mods.fit(mod.div)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"1653.3621771427288","left":"2049.543698196163","inputs":{},"outputs":{}},"0.37161643174388537":{"definition":"//\n// note\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2017\n// Modified by Francisco Sanchez 2019\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'note'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.text.value = 'STEP 1A: For the wax rough pass press calculate here. Then go to step 2.'\n    }\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {}\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //\n        // text\n        //\n        var text = document.createElement('textarea')\n        text.style.backgroundColor = '#D4E157';\n        text.setAttribute('spellcheck', 'false')\n        text.setAttribute('rows', mods.ui.rows)\n        text.setAttribute('cols', mods.ui.cols)\n        //\n        // watch textarea for resize\n        //\n        new MutationObserver(update_module).observe(text, {\n            attributes: true,\n            attributeFilter: [\"style\"]\n        })\n        div.appendChild(text)\n        mod.text = text\n        div.appendChild(document.createElement('br'))\n    }\n    //\n    // local functions\n    //\n    //\n    // update module\n    //\n    function update_module() {\n        mods.fit(mod.div)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"806.6113239363647","left":"2003.978281573364","inputs":{},"outputs":{}},"0.811671411949111":{"definition":"//\n// note\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2017\n// Modified by Francisco Sanchez 2019\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'note'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.text.value = 'STEP 2: Adjust the job settings and zero the machine. Then go to step 3.'\n    }\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {}\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //\n        // text\n        //\n        var text = document.createElement('textarea')\n        text.style.backgroundColor = '#D4E157';\n        text.setAttribute('spellcheck', 'false')\n        text.setAttribute('rows', mods.ui.rows)\n        text.setAttribute('cols', mods.ui.cols)\n        //\n        // watch textarea for resize\n        //\n        new MutationObserver(update_module).observe(text, {\n            attributes: true,\n            attributeFilter: [\"style\"]\n        })\n        div.appendChild(text)\n        mod.text = text\n        div.appendChild(document.createElement('br'))\n    }\n    //\n    // local functions\n    //\n    //\n    // update module\n    //\n    function update_module() {\n        mods.fit(mod.div)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"1471.0499808235327","left":"3000.8439828364176","inputs":{},"outputs":{}},"0.23290005713806028":{"definition":"//\n// serial server module\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2016\n// Modified by: Francisco Sanchez 2019\n//            : xytaz         Mar-2020\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'WebSocket serial'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.address.value = '127.0.0.1'\n        mod.port.value = '1235'\n        mod.device.value = 'Serialport not found'\n        mod.baud.value = '115200'\n        mod.flow_xonxoff.checked = true\n        mod.socket = null\n        socket_open()\n    }\n    //\n    // inputs\n    //\n    var inputs = {\n        transmit: {\n            type: 'string',\n            event: function(evt) {\n                serial_send_string(evt.detail)\n            }\n        },\n        file: {\n            type: 'object',\n            event: function(evt) {\n                if (evt.detail.type == 'command') {\n                    mod.command = evt.detail\n                    socket_send(JSON.stringify(mod.command))\n                } else if (evt.detail.type == 'file') {\n                    mod.job = evt.detail\n                    mod.job.type = 'file'\n                    mod.label.nodeValue = 'send file'\n                    mod.labelspan.style.fontWeight = 'bold'\n                }\n            }\n        }\n    }\n    //\n    // outputs\n    //\n    var outputs = {\n        receive: {\n            type: 'character',\n            event: function(str) {\n                mods.output(mod, 'receive', str)\n            }\n        }\n    }\n    //\n\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n\n\n        //\n        // server\n        //\n        var a = document.createElement('a')\n        a.href = './js/serialserver.js'\n        a.innerHTML = 'serialserver.js:'\n        a.target = '_blank'\n        div.appendChild(a)\n        div.appendChild(document.createElement('br'))\n        //\n        // status\n        //\n        var input = document.createElement('input')\n        input.classList.add(\"marquee\")\n        input.disabled = true\n        input.type = 'text'\n        input.size = 19\n        div.appendChild(input)\n        mod.status = input\n        div.appendChild(document.createElement('br'))\n\n        //\n        // address\n        //\n        div.appendChild(document.createTextNode('address: '))\n        input = document.createElement('input')\n        input.type = 'text'\n        input.size = 10\n        div.appendChild(input)\n        mod.address = input\n        div.appendChild(document.createElement('br'))\n        //\n        // port\n        //\n        div.appendChild(document.createTextNode('\\u00a0\\u00a0\\u00a0port: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 10\n        div.appendChild(input)\n        mod.port = input\n        div.appendChild(document.createElement('br'))\n        //\n        // open/close\n        //\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('open socket'))\n        btn.addEventListener('click', function() {\n            socket_open()\n        })\n        div.appendChild(btn)\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('close socket'))\n        btn.addEventListener('click', function() {\n            socket_close()\n        })\n        div.appendChild(btn)\n        div.appendChild(document.createElement('hr'))\n\n\n\n        //\n        // serial\n        //\n        div.appendChild(document.createTextNode('serial device:'))\n        div.appendChild(document.createElement('br'))\n        //\n        // device\n        //\n\n        var select = document.createElement('select')\n\n        var el = document.createElement('option')\n\n        el.textContent = 'Serialport not found'\n        el.value = 'Serialport not found'\n        select.appendChild(el)\n        div.appendChild(select)\n        mod.device = select\n\n        div.appendChild(document.createElement('br'))\n        //\n        // baud rate\n        //\n        div.appendChild(document.createTextNode('baud rate: '))\n        var input = document.createElement('input')\n        input.type = 'text'\n        input.size = 7\n        div.appendChild(input)\n        mod.baud = input\n        div.appendChild(document.createTextNode(' (bps)'))\n        div.appendChild(document.createElement('br'))\n\n        //\n        // flow control\n        //\n        div.appendChild(document.createTextNode('flow control:'))\n        div.appendChild(document.createElement('br'))\n        var input = document.createElement('input')\n        input.type = 'radio'\n        input.name = mod.div.id + 'flow'\n        input.id = mod.div.id + 'flow_none'\n        div.appendChild(input)\n        mod.flow_none = input\n        div.appendChild(document.createTextNode('none\\u00a0\\u00a0\\u00a0'))\n        div.appendChild(document.createElement('br'))\n        var input = document.createElement('input')\n        input.type = 'radio'\n        input.name = mod.div.id + 'flow'\n        input.id = mod.div.id + 'flow_xonxoff'\n        div.appendChild(input)\n        mod.flow_xonxoff = input\n        div.appendChild(document.createTextNode('XONXOFF'))\n        div.appendChild(document.createElement('br'))\n        var input = document.createElement('input')\n        input.type = 'radio'\n        input.name = mod.div.id + 'flow'\n        input.id = mod.div.id + 'flow_rtscts'\n        div.appendChild(input)\n        mod.flow_rtscts = input\n        mod.flow_rtscts.checked = true\n        div.appendChild(document.createTextNode('RTSCTS\\u00a0'))\n        div.appendChild(document.createElement('br'))\n        div.appendChild(document.createElement('br'))\n\n        //\n        // line ending\n        //\n        //div.appendChild(document.createTextNode('line ending:'))\n        //div.appendChild(document.createElement('br'))   \n        var input = document.createElement('select')\n        input.type = 'select'\n\n        var option_labels = ['line ending: none', 'line ending: NL', 'line ending: CR', 'line ending: NL + CR']\n        var option_values = ['none', 'nl', 'cr', 'nlcr']\n        for (var i = 0; i < option_labels.length; i++) {\n            var option = document.createElement('option')\n            option.text = option_labels[i]\n            option.value = option_values[i]\n            input.appendChild(option)\n        }\n\n        div.appendChild(input)\n        mod.line_ending = input\n\n        div.appendChild(document.createElement('br'))\n\n        //\n        // open/close\n        //\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('open port'))\n        btn.addEventListener('click', function() {\n            serial_open()\n        })\n        div.appendChild(btn)\n        var btn = document.createElement('button')\n        btn.style.margin = 1\n        btn.appendChild(document.createTextNode('close port'))\n        btn.addEventListener('click', function() {\n            serial_close()\n        })\n        div.appendChild(btn)\n        div.appendChild(document.createElement('hr'))\n\n\n        //\n        // file button\n        //\n        var btn = document.createElement('button')\n        btn.style.padding = mods.ui.padding\n        btn.style.margin = 1\n        var span = document.createElement('span')\n        var text = document.createTextNode('waiting for file')\n        mod.label = text\n        span.appendChild(text)\n        mod.labelspan = span\n        btn.appendChild(span)\n        btn.addEventListener('click', function() {\n            if (mod.socket == null) {\n                mod.status.value = \"can't send, not open\"\n            } else if (mod.label.nodeValue == 'send file') {\n                socket_send(JSON.stringify(mod.job))\n                mod.label.nodeValue = 'cancel'\n            } else if (mod.label.nodeValue == 'cancel') {\n                mod.command = {}\n                mod.command.type = 'cancel'\n                socket_send(JSON.stringify(mod.command))\n            }\n        })\n        div.appendChild(btn)\n    }\n\n\n    //\n    // local functions\n    //\n    function socket_open() {\n        var url = \"ws://\" + mod.address.value + ':' + mod.port.value\n        mod.socket = new WebSocket(url)\n        mod.socket.onopen = function(event) {\n            mod.status.value = \"socket opened\"\n        }\n        mod.socket.onerror = function(event) {\n            mod.status.value = \"can not open\"\n            mod.socket = null\n        }\n        mod.socket.onmessage = function(event) {\n            mod.status.value = event.data\n            outputs.receive.event(event.data)\n            if ((event.data == 'done') || (event.data == 'cancel') || (event.data.slice(0, 5) == 'error')) {\n                mod.label.nodeValue = 'waiting for file'\n                mod.labelspan.style.fontWeight = 'normal'\n            } else if (event.data[0] === '{') { // If receiving an object\n                console.log('received object')\n                var portObject = JSON.parse(event.data) // get the object\n                var portList = portObject['portList'] // extract the list\n                if (portList) {\n                    while (mod.device.hasChildNodes()) {\n                        mod.device.removeChild(mod.device.lastChild); //remove all previous options\n                    }\n\n                    for (var i = 0; i < portList.length; i++) {\n                        var port = portList[i];\n                        var el = document.createElement('option')\n                        el.textContent = port\n                        el.value = port\n                        mod.device.appendChild(el)\n                    }\n\n                    if (portList.length == 0) {\n                        var el = document.createElement('option')\n                        el.textContent = 'Serialport not found'\n                        el.value = 'Serialport not found'\n                        mod.device.appendChild(el)\n                    }\n\n                }\n            }\n\n        }\n    }\n\n    function socket_close() {\n        mod.socket.close()\n        mod.status.value = \"socket closed\"\n        mod.socket = null\n    }\n\n    function socket_send(msg) {\n        if (mod.socket != null) {\n            mod.status.value = \"send\"\n            mod.socket.send(msg)\n        } else {\n            mod.status.value = \"can't send, not open\"\n        }\n    }\n\n    function serial_open() {\n        if (mod.socket == null) {\n            mod.status.value = \"socket not open\"\n        } else {\n            if (mod.device.value == \"Serialport not found\") {\n                mod.status.value = \"no serial devices found\"\n            } else {\n                var msg = {}\n                msg.type = 'open'\n                msg.device = mod.device.value\n                msg.baud = mod.baud.value\n                if (mod.flow_none.checked)\n                    msg.flow = 'none'\n                else if (mod.flow_xonxoff.checked)\n                    msg.flow = 'xonxoff'\n                else if (mod.flow_rtscts.checked)\n                    msg.flow = 'rtscts'\n                mod.socket.send(JSON.stringify(msg))\n            }\n        }\n    }\n\n    function serial_close() {\n        if (mod.socket == null) {\n            mod.status.value = \"socket not open\"\n        } else {\n            if (mod.device.value == \"Serialport not found\") {\n                mod.status.value = \"serial device not open\"\n            } else {\n\n                var msg = {}\n                msg.type = 'close'\n                msg.device = mod.device.value\n                mod.socket.send(JSON.stringify(msg))\n            }\n        }\n    }\n\n    function serial_send_string(str) {\n        if (mod.socket == null) {\n            mod.status.value = \"socket not open\"\n        } else {\n            var msg = {}\n            msg.type = 'string'\n            msg.string = str\n            msg.line_ending = mod.line_ending.value\n            mod.socket.send(JSON.stringify(msg))\n            mod.status.value = 'transmit'\n        }\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"1294.9568824441212","left":"3730.9749463434573","inputs":{},"outputs":{}},"0.8973757219249795":{"definition":"//\n// note\n//\n// Neil Gershenfeld \n// (c) Massachusetts Institute of Technology 2017\n// Modified by Francisco Sanchez 2019\n// \n// This work may be reproduced, modified, distributed, performed, and \n// displayed for any purpose, but must acknowledge the mods\n// project. Copyright is retained and must be preserved. The work is \n// provided as is; no warranty is provided, and users accept all \n// liability.\n//\n// closure\n//\n(function() {\n    //\n    // module globals\n    //\n    var mod = {}\n    //\n    // name\n    //\n    var name = 'note'\n    //\n    // initialization\n    //\n    var init = function() {\n        mod.text.value = 'STEP 3: Select CR line ending and send the file to the machine.'\n    }\n    //\n    // inputs\n    //\n    var inputs = {}\n    //\n    // outputs\n    //\n    var outputs = {}\n    //\n    // interface\n    //\n    var interface = function(div) {\n        mod.div = div\n        //\n        // text\n        //\n        var text = document.createElement('textarea')\n        text.style.backgroundColor = '#D4E157';\n        text.setAttribute('spellcheck', 'false')\n        text.setAttribute('rows', mods.ui.rows)\n        text.setAttribute('cols', mods.ui.cols)\n        //\n        // watch textarea for resize\n        //\n        new MutationObserver(update_module).observe(text, {\n            attributes: true,\n            attributeFilter: [\"style\"]\n        })\n        div.appendChild(text)\n        mod.text = text\n        div.appendChild(document.createElement('br'))\n    }\n    //\n    // local functions\n    //\n    //\n    // update module\n    //\n    function update_module() {\n        mods.fit(mod.div)\n    }\n    //\n    // return values\n    //\n    return ({\n        mod: mod,\n        name: name,\n        init: init,\n        inputs: inputs,\n        outputs: outputs,\n        interface: interface\n    })\n}())\n","top":"1630.3360340342274","left":"3573.4829225886024","inputs":{},"outputs":{}}},"links":["{\"source\":\"{\\\"id\\\":\\\"0.9712638252399309\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"map\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.14496496987822938\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"map\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.14496496987822938\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"toolpath\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.6999841802960824\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"path\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.07944144280928633\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"image\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.8903773266711255\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"image\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.6488303557466412\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"image\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.47383876715576023\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"image\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.8903773266711255\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"image\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.749132408760488\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"image\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.47383876715576023\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"distances\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.7667165137781767\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"distances\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.7667165137781767\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"image\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.07944144280928633\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"image\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.32304064019646705\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"image\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.6488303557466412\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"image\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.32304064019646705\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"imageInfo\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.9325875387173613\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"imageInfo\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.749132408760488\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"path\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.9325875387173613\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"path\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.9325875387173613\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"depth\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.32304064019646705\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"settings\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.9325875387173613\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"offset\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.7667165137781767\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"offset\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.349185945662254\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"mesh\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.992597256007513\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"mesh\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.992597256007513\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"mesh\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.9712638252399309\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"mesh\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.9325875387173613\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"toolpath\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.6999841802960824\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"path\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.992597256007513\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"mesh\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.32304064019646705\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"mesh\\\"}\"}","{\"source\":\"{\\\"id\\\":\\\"0.6999841802960824\\\",\\\"type\\\":\\\"outputs\\\",\\\"name\\\":\\\"file\\\"}\",\"dest\":\"{\\\"id\\\":\\\"0.23290005713806028\\\",\\\"type\\\":\\\"inputs\\\",\\\"name\\\":\\\"file\\\"}\"}"]}